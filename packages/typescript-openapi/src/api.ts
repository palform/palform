/* tslint:disable */
/* eslint-disable */
/**
 * palform-backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface APIAdminUser
 */
export interface APIAdminUser {
    /**
     * 
     * @type {string}
     * @memberof APIAdminUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIAdminUser
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof APIAdminUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof APIAdminUser
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface APIAdminUserSecondAuthenticationFactor
 */
export interface APIAdminUserSecondAuthenticationFactor {
    /**
     * 
     * @type {string}
     * @memberof APIAdminUserSecondAuthenticationFactor
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIAdminUserSecondAuthenticationFactor
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof APIAdminUserSecondAuthenticationFactor
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface APIAuditLogEntry
 */
export interface APIAuditLogEntry {
    /**
     * 
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    'user_display_name': string;
    /**
     * 
     * @type {AuditLogVerbEnum}
     * @memberof APIAuditLogEntry
     */
    'verb': AuditLogVerbEnum;
    /**
     * 
     * @type {AuditLogTargetResourceEnum}
     * @memberof APIAuditLogEntry
     */
    'target_resource_type': AuditLogTargetResourceEnum;
    /**
     * 
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    'target_resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APIAuditLogEntry
     */
    'note'?: string | null;
}


/**
 * 
 * @export
 * @interface APIBillingCustomer
 */
export interface APIBillingCustomer {
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomer
     */
    'entity_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomer
     */
    'email'?: string | null;
    /**
     * 
     * @type {APIBillingCustomerAddress}
     * @memberof APIBillingCustomer
     */
    'address'?: APIBillingCustomerAddress | null;
    /**
     * 
     * @type {APIBillingCustomerPaymentMethod}
     * @memberof APIBillingCustomer
     */
    'default_payment_method'?: APIBillingCustomerPaymentMethod | null;
}
/**
 * 
 * @export
 * @interface APIBillingCustomerAddress
 */
export interface APIBillingCustomerAddress {
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerAddress
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerAddress
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerAddress
     */
    'line1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerAddress
     */
    'line2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerAddress
     */
    'postal_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerAddress
     */
    'state'?: string | null;
}
/**
 * @type APIBillingCustomerPaymentMethod
 * @export
 */
export type APIBillingCustomerPaymentMethod = APIBillingCustomerPaymentMethodOneOf | APIBillingCustomerPaymentMethodOneOf1;

/**
 * 
 * @export
 * @interface APIBillingCustomerPaymentMethodCard
 */
export interface APIBillingCustomerPaymentMethodCard {
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerPaymentMethodCard
     */
    'last4': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerPaymentMethodCard
     */
    'brand': string;
}
/**
 * 
 * @export
 * @interface APIBillingCustomerPaymentMethodOneOf
 */
export interface APIBillingCustomerPaymentMethodOneOf {
    /**
     * 
     * @type {APIBillingCustomerPaymentMethodCard}
     * @memberof APIBillingCustomerPaymentMethodOneOf
     */
    'Card': APIBillingCustomerPaymentMethodCard;
}
/**
 * 
 * @export
 * @interface APIBillingCustomerPaymentMethodOneOf1
 */
export interface APIBillingCustomerPaymentMethodOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof APIBillingCustomerPaymentMethodOneOf1
     */
    'Other': string;
}
/**
 * 
 * @export
 * @interface APIBillingInvoice
 */
export interface APIBillingInvoice {
    /**
     * 
     * @type {string}
     * @memberof APIBillingInvoice
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof APIBillingInvoice
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof APIBillingInvoice
     */
    'currency': string;
    /**
     * 
     * @type {APIBillingInvoiceStatus}
     * @memberof APIBillingInvoice
     */
    'status': APIBillingInvoiceStatus;
    /**
     * 
     * @type {string}
     * @memberof APIBillingInvoice
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingInvoice
     */
    'url'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const APIBillingInvoiceStatus = {
    Draft: 'Draft',
    Open: 'Open',
    Paid: 'Paid',
    Uncollectible: 'Uncollectible',
    Void: 'Void'
} as const;

export type APIBillingInvoiceStatus = typeof APIBillingInvoiceStatus[keyof typeof APIBillingInvoiceStatus];


/**
 * 
 * @export
 * @interface APIBillingPlan
 */
export interface APIBillingPlan {
    /**
     * 
     * @type {string}
     * @memberof APIBillingPlan
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingPlan
     */
    'stripe_product_id': string;
    /**
     * 
     * @type {APIBillingPlanPrice}
     * @memberof APIBillingPlan
     */
    'price_monthly': APIBillingPlanPrice;
    /**
     * 
     * @type {APIBillingPlanPrice}
     * @memberof APIBillingPlan
     */
    'price_annually': APIBillingPlanPrice;
    /**
     * 
     * @type {string}
     * @memberof APIBillingPlan
     */
    'currency': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIBillingPlan
     */
    'features': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof APIBillingPlan
     */
    'highlight': boolean;
}
/**
 * 
 * @export
 * @interface APIBillingPlanPrice
 */
export interface APIBillingPlanPrice {
    /**
     * 
     * @type {string}
     * @memberof APIBillingPlanPrice
     */
    'stripe_price_id': string;
    /**
     * 
     * @type {number}
     * @memberof APIBillingPlanPrice
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface APIBillingSubscription
 */
export interface APIBillingSubscription {
    /**
     * 
     * @type {string}
     * @memberof APIBillingSubscription
     */
    'stripe_subscription_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingSubscription
     */
    'stripe_plan_product_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingSubscription
     */
    'stripe_plan_price_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof APIBillingSubscription
     */
    'is_trial': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIBillingSubscription
     */
    'plan_name': string;
    /**
     * 
     * @type {APIBillingSubscriptionFrequency}
     * @memberof APIBillingSubscription
     */
    'plan_frequency': APIBillingSubscriptionFrequency;
    /**
     * 
     * @type {string}
     * @memberof APIBillingSubscription
     */
    'currency': string;
    /**
     * 
     * @type {APIBillingPlanPrice}
     * @memberof APIBillingSubscription
     */
    'price': APIBillingPlanPrice;
    /**
     * 
     * @type {string}
     * @memberof APIBillingSubscription
     */
    'period_end': string;
    /**
     * 
     * @type {boolean}
     * @memberof APIBillingSubscription
     */
    'canceling_at_end': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const APIBillingSubscriptionFrequency = {
    Monthly: 'Monthly',
    Annually: 'Annually'
} as const;

export type APIBillingSubscriptionFrequency = typeof APIBillingSubscriptionFrequency[keyof typeof APIBillingSubscriptionFrequency];


/**
 * 
 * @export
 * @interface APIBillingUpcomingInvoice
 */
export interface APIBillingUpcomingInvoice {
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoice
     */
    'invoice_date': string;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoice
     */
    'amount_due': number;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoice
     */
    'total_amount': number;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoice
     */
    'tax_amount': number;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoice
     */
    'starting_balance': number;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoice
     */
    'ending_balance': number;
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoice
     */
    'currency': string;
    /**
     * 
     * @type {Array<APIBillingUpcomingInvoiceLine>}
     * @memberof APIBillingUpcomingInvoice
     */
    'lines': Array<APIBillingUpcomingInvoiceLine>;
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoice
     */
    'period_start': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoice
     */
    'period_end': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoice
     */
    'next_payment_attempt': string;
    /**
     * 
     * @type {Array<APIBillingUpcomingInvoicePromotion>}
     * @memberof APIBillingUpcomingInvoice
     */
    'promotions': Array<APIBillingUpcomingInvoicePromotion>;
}
/**
 * 
 * @export
 * @interface APIBillingUpcomingInvoiceLine
 */
export interface APIBillingUpcomingInvoiceLine {
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'stripe_price_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'unit_price': number;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'unit_price_per': number;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'total_price': number;
    /**
     * 
     * @type {boolean}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'proration': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoiceLine
     */
    'stripe_description': string;
}
/**
 * 
 * @export
 * @interface APIBillingUpcomingInvoicePromotion
 */
export interface APIBillingUpcomingInvoicePromotion {
    /**
     * 
     * @type {string}
     * @memberof APIBillingUpcomingInvoicePromotion
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoicePromotion
     */
    'percent_off'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof APIBillingUpcomingInvoicePromotion
     */
    'amount_off'?: number | null;
}
/**
 * 
 * @export
 * @interface APICountryWithCallingCode
 */
export interface APICountryWithCallingCode {
    /**
     * 
     * @type {string}
     * @memberof APICountryWithCallingCode
     */
    'flag_emoji': string;
    /**
     * 
     * @type {string}
     * @memberof APICountryWithCallingCode
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof APICountryWithCallingCode
     */
    'calling_code': number;
}
/**
 * 
 * @export
 * @interface APICountryWithISOCode
 */
export interface APICountryWithISOCode {
    /**
     * 
     * @type {string}
     * @memberof APICountryWithISOCode
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APICountryWithISOCode
     */
    'iso_code': string;
}
/**
 * 
 * @export
 * @interface APIEntitlementInfo
 */
export interface APIEntitlementInfo {
    /**
     * 
     * @type {number}
     * @memberof APIEntitlementInfo
     */
    'user_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof APIEntitlementInfo
     */
    'response_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof APIEntitlementInfo
     */
    'question_per_form_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof APIEntitlementInfo
     */
    'form_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof APIEntitlementInfo
     */
    'team_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof APIEntitlementInfo
     */
    'branding_count'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'export': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'import_keys': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'subdomain': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'crypto_details': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'audit': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'priority_support': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'oidc': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'submission_auto_delete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIEntitlementInfo
     */
    'form_captcha': boolean;
}
/**
 * @type APIEntitlementRequest
 * @export
 */
export type APIEntitlementRequest = APIEntitlementRequestOneOf | string;

/**
 * 
 * @export
 * @interface APIEntitlementRequestOneOf
 */
export interface APIEntitlementRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof APIEntitlementRequestOneOf
     */
    'QuestionPerFormCount': string;
}
/**
 * @type APIError
 * @export
 */
export type APIError = APIErrorOneOf | APIErrorOneOf1 | APIErrorOneOf2 | APIErrorOneOf3 | string;

/**
 * 
 * @export
 * @interface APIErrorOneOf
 */
export interface APIErrorOneOf {
    /**
     * 
     * @type {string}
     * @memberof APIErrorOneOf
     */
    'BadRequest': string;
}
/**
 * 
 * @export
 * @interface APIErrorOneOf1
 */
export interface APIErrorOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof APIErrorOneOf1
     */
    'ValidationError': string;
}
/**
 * 
 * @export
 * @interface APIErrorOneOf2
 */
export interface APIErrorOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof APIErrorOneOf2
     */
    'CaptchaError': string;
}
/**
 * 
 * @export
 * @interface APIErrorOneOf3
 */
export interface APIErrorOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof APIErrorOneOf3
     */
    'SubscriptionLimit': string;
}
/**
 * 
 * @export
 * @interface APIExchangedShortLink
 */
export interface APIExchangedShortLink {
    /**
     * 
     * @type {string}
     * @memberof APIExchangedShortLink
     */
    'fill_token_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIExchangedShortLink
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIExchangedShortLink
     */
    'form_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIExchangedShortLink
     */
    'expires_at'?: string | null;
}
/**
 * 
 * @export
 * @interface APIFillToken
 */
export interface APIFillToken {
    /**
     * 
     * @type {string}
     * @memberof APIFillToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIFillToken
     */
    'form_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIFillToken
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APIFillToken
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFillToken
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof APIFillToken
     */
    'short_link'?: string | null;
}
/**
 * 
 * @export
 * @interface APIForm
 */
export interface APIForm {
    /**
     * 
     * @type {string}
     * @memberof APIForm
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIForm
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIForm
     */
    'editor_name': string;
    /**
     * 
     * @type {number}
     * @memberof APIForm
     */
    'response_count': number;
    /**
     * 
     * @type {string}
     * @memberof APIForm
     */
    'team_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIForm
     */
    'branding_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof APIForm
     */
    'notification_email': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIForm
     */
    'notification_webhook_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof APIForm
     */
    'auto_delete_submission_after_days'?: number | null;
    /**
     * 
     * @type {APIFormEndConfiguration}
     * @memberof APIForm
     */
    'end_configuration': APIFormEndConfiguration;
    /**
     * 
     * @type {boolean}
     * @memberof APIForm
     */
    'enable_captcha': boolean;
}
/**
 * 
 * @export
 * @interface APIFormBranding
 */
export interface APIFormBranding {
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'google_font': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'primary_color': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'accent_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'logo_asset_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'background_image_asset_id'?: string | null;
    /**
     * 
     * @type {FormBrandingBorderRoundingEnum}
     * @memberof APIFormBranding
     */
    'border_rounding': FormBrandingBorderRoundingEnum;
    /**
     * 
     * @type {FormBrandingSpacingEnum}
     * @memberof APIFormBranding
     */
    'spacing': FormBrandingSpacingEnum;
    /**
     * 
     * @type {FormBrandingFontSizeEnum}
     * @memberof APIFormBranding
     */
    'font_size': FormBrandingFontSizeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof APIFormBranding
     */
    'include_palform_attribution': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'terms_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'privacy_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBranding
     */
    'extra_footer_message'?: string | null;
    /**
     * 
     * @type {FormBrandingBorderIntensityEnum}
     * @memberof APIFormBranding
     */
    'border_intensity': FormBrandingBorderIntensityEnum;
    /**
     * 
     * @type {FormBrandingBorderIntensityEnum}
     * @memberof APIFormBranding
     */
    'border_shadow_intensity': FormBrandingBorderIntensityEnum;
    /**
     * 
     * @type {boolean}
     * @memberof APIFormBranding
     */
    'e2ee_badge': boolean;
}


/**
 * 
 * @export
 * @interface APIFormBrandingAccess
 */
export interface APIFormBrandingAccess {
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingAccess
     */
    'team_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingAccess
     */
    'team_name': string;
}
/**
 * 
 * @export
 * @interface APIFormBrandingRequest
 */
export interface APIFormBrandingRequest {
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'primary_color': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'accent_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'google_font': string;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'logo_asset_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'background_image_asset_id'?: string | null;
    /**
     * 
     * @type {FormBrandingBorderRoundingEnum}
     * @memberof APIFormBrandingRequest
     */
    'border_rounding': FormBrandingBorderRoundingEnum;
    /**
     * 
     * @type {FormBrandingSpacingEnum}
     * @memberof APIFormBrandingRequest
     */
    'spacing': FormBrandingSpacingEnum;
    /**
     * 
     * @type {FormBrandingFontSizeEnum}
     * @memberof APIFormBrandingRequest
     */
    'font_size': FormBrandingFontSizeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof APIFormBrandingRequest
     */
    'include_palform_attribution': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'terms_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'privacy_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormBrandingRequest
     */
    'extra_footer_message'?: string | null;
    /**
     * 
     * @type {FormBrandingBorderIntensityEnum}
     * @memberof APIFormBrandingRequest
     */
    'border_intensity': FormBrandingBorderIntensityEnum;
    /**
     * 
     * @type {FormBrandingBorderIntensityEnum}
     * @memberof APIFormBrandingRequest
     */
    'border_shadow_intensity': FormBrandingBorderIntensityEnum;
    /**
     * 
     * @type {boolean}
     * @memberof APIFormBrandingRequest
     */
    'e2ee_badge': boolean;
}


/**
 * 
 * @export
 * @interface APIFormEndConfiguration
 */
export interface APIFormEndConfiguration {
    /**
     * 
     * @type {string}
     * @memberof APIFormEndConfiguration
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormEndConfiguration
     */
    'redirect_to'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof APIFormEndConfiguration
     */
    'show_restart': boolean;
}
/**
 * 
 * @export
 * @interface APIFormWithQuestions
 */
export interface APIFormWithQuestions {
    /**
     * 
     * @type {APIFrontendForm}
     * @memberof APIFormWithQuestions
     */
    'f': APIFrontendForm;
    /**
     * 
     * @type {Array<APIQuestion>}
     * @memberof APIFormWithQuestions
     */
    'q': Array<APIQuestion>;
    /**
     * 
     * @type {Array<APIQuestionGroup>}
     * @memberof APIFormWithQuestions
     */
    'g': Array<APIQuestionGroup>;
    /**
     * 
     * @type {APIFormBranding}
     * @memberof APIFormWithQuestions
     */
    'b'?: APIFormBranding | null;
    /**
     * 
     * @type {string}
     * @memberof APIFormWithQuestions
     */
    'o': string;
}
/**
 * 
 * @export
 * @interface APIFrontendForm
 */
export interface APIFrontendForm {
    /**
     * 
     * @type {string}
     * @memberof APIFrontendForm
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIFrontendForm
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIFrontendForm
     */
    'editor_name': string;
    /**
     * 
     * @type {APIFormEndConfiguration}
     * @memberof APIFrontendForm
     */
    'end_configuration': APIFormEndConfiguration;
    /**
     * 
     * @type {boolean}
     * @memberof APIFrontendForm
     */
    'enable_captcha': boolean;
}
/**
 * 
 * @export
 * @interface APIGenericLocation
 */
export interface APIGenericLocation {
    /**
     * 
     * @type {number}
     * @memberof APIGenericLocation
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof APIGenericLocation
     */
    'lng': number;
}
/**
 * 
 * @export
 * @interface APIOrgMember
 */
export interface APIOrgMember {
    /**
     * 
     * @type {string}
     * @memberof APIOrgMember
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrgMember
     */
    'user_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrgMember
     */
    'organisation_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof APIOrgMember
     */
    'is_admin': boolean;
}
/**
 * 
 * @export
 * @interface APIOrganisation
 */
export interface APIOrganisation {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisation
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisation
     */
    'subdomain'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof APIOrganisation
     */
    'uses_oidc': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIOrganisation
     */
    'billing_allow_overage': boolean;
}
/**
 * 
 * @export
 * @interface APIOrganisationAuthConfig
 */
export interface APIOrganisationAuthConfig {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthConfig
     */
    'oidc_discovery_url': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthConfig
     */
    'client_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthConfig
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthConfig
     */
    'team_mapping_field_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof APIOrganisationAuthConfig
     */
    'revoke_team_mappings'?: boolean | null;
}
/**
 * 
 * @export
 * @interface APIOrganisationAuthTeamMapping
 */
export interface APIOrganisationAuthTeamMapping {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthTeamMapping
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthTeamMapping
     */
    'team_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthTeamMapping
     */
    'team_name': string;
    /**
     * 
     * @type {OrganisationMemberRoleEnum}
     * @memberof APIOrganisationAuthTeamMapping
     */
    'role': OrganisationMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthTeamMapping
     */
    'field_value': string;
}


/**
 * 
 * @export
 * @interface APIOrganisationAuthTeamMappingRequest
 */
export interface APIOrganisationAuthTeamMappingRequest {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthTeamMappingRequest
     */
    'team_id': string;
    /**
     * 
     * @type {OrganisationMemberRoleEnum}
     * @memberof APIOrganisationAuthTeamMappingRequest
     */
    'role': OrganisationMemberRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationAuthTeamMappingRequest
     */
    'field_value': string;
}


/**
 * 
 * @export
 * @interface APIOrganisationInvite
 */
export interface APIOrganisationInvite {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationInvite
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof APIOrganisationInvite
     */
    'single_use': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationInvite
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationInvite
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface APIOrganisationInvitePreview
 */
export interface APIOrganisationInvitePreview {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationInvitePreview
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationInvitePreview
     */
    'org_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationInvitePreview
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface APIOrganisationTeam
 */
export interface APIOrganisationTeam {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationTeam
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationTeam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationTeam
     */
    'organisation_id': string;
    /**
     * 
     * @type {number}
     * @memberof APIOrganisationTeam
     */
    'num_members': number;
    /**
     * 
     * @type {boolean}
     * @memberof APIOrganisationTeam
     */
    'is_default'?: boolean | null;
}
/**
 * 
 * @export
 * @interface APIOrganisationTeamMember
 */
export interface APIOrganisationTeamMember {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationTeamMember
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationTeamMember
     */
    'user_display_name': string;
    /**
     * 
     * @type {OrganisationMemberRoleEnum}
     * @memberof APIOrganisationTeamMember
     */
    'role': OrganisationMemberRoleEnum;
}


/**
 * 
 * @export
 * @interface APIOrganisationTeamMembership
 */
export interface APIOrganisationTeamMembership {
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationTeamMembership
     */
    'team_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIOrganisationTeamMembership
     */
    'name': string;
    /**
     * 
     * @type {OrganisationMemberRoleEnum}
     * @memberof APIOrganisationTeamMembership
     */
    'my_role': OrganisationMemberRoleEnum;
}


/**
 * 
 * @export
 * @interface APIQuestion
 */
export interface APIQuestion {
    /**
     * 
     * @type {string}
     * @memberof APIQuestion
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIQuestion
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof APIQuestion
     */
    'internal_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIQuestion
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestion
     */
    'required': boolean;
    /**
     * 
     * @type {APIQuestionConfiguration}
     * @memberof APIQuestion
     */
    'configuration': APIQuestionConfiguration;
    /**
     * 
     * @type {number}
     * @memberof APIQuestion
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof APIQuestion
     */
    'group_id': string;
}
/**
 * @type APIQuestionConfiguration
 * @export
 */
export type APIQuestionConfiguration = APIQuestionConfigurationOneOf | APIQuestionConfigurationOneOf1 | APIQuestionConfigurationOneOf10 | APIQuestionConfigurationOneOf2 | APIQuestionConfigurationOneOf3 | APIQuestionConfigurationOneOf4 | APIQuestionConfigurationOneOf5 | APIQuestionConfigurationOneOf6 | APIQuestionConfigurationOneOf7 | APIQuestionConfigurationOneOf8 | APIQuestionConfigurationOneOf9;

/**
 * A purely informational non-interactive question that serves as (e.g.) a section heading.
 * @export
 * @interface APIQuestionConfigurationOneOf
 */
export interface APIQuestionConfigurationOneOf {
    /**
     * 
     * @type {APIQuestionConfigurationOneOfInfo}
     * @memberof APIQuestionConfigurationOneOf
     */
    'info': APIQuestionConfigurationOneOfInfo;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf1
 */
export interface APIQuestionConfigurationOneOf1 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf1Text}
     * @memberof APIQuestionConfigurationOneOf1
     */
    'text': APIQuestionConfigurationOneOf1Text;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf10
 */
export interface APIQuestionConfigurationOneOf10 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf10Hidden}
     * @memberof APIQuestionConfigurationOneOf10
     */
    'hidden': APIQuestionConfigurationOneOf10Hidden;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf10Hidden
 */
export interface APIQuestionConfigurationOneOf10Hidden {
    /**
     * 
     * @type {string}
     * @memberof APIQuestionConfigurationOneOf10Hidden
     */
    'parameter_name': string;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf1Text
 */
export interface APIQuestionConfigurationOneOf1Text {
    /**
     * Will use a textarea instead of an input
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf1Text
     */
    'is_long': boolean;
    /**
     * Use client-side validation to ensure a valid input. Not validated server-side due to encryption, so this doesn\'t guarantee valid data.
     * @type {APIQuestionTextValidator}
     * @memberof APIQuestionConfigurationOneOf1Text
     */
    'validator'?: APIQuestionTextValidator | null;
}


/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf2
 */
export interface APIQuestionConfigurationOneOf2 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf2Choice}
     * @memberof APIQuestionConfigurationOneOf2
     */
    'choice': APIQuestionConfigurationOneOf2Choice;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf2Choice
 */
export interface APIQuestionConfigurationOneOf2Choice {
    /**
     * 
     * @type {Array<string>}
     * @memberof APIQuestionConfigurationOneOf2Choice
     */
    'options': Array<string>;
    /**
     * Support multiple options in a submission (i.e. checkboxes instead of radio buttons)
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf2Choice
     */
    'multi': boolean;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf3
 */
export interface APIQuestionConfigurationOneOf3 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf3Scale}
     * @memberof APIQuestionConfigurationOneOf3
     */
    'scale': APIQuestionConfigurationOneOf3Scale;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf3Scale
 */
export interface APIQuestionConfigurationOneOf3Scale {
    /**
     * 
     * @type {number}
     * @memberof APIQuestionConfigurationOneOf3Scale
     */
    'min': number;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionConfigurationOneOf3Scale
     */
    'min_label'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof APIQuestionConfigurationOneOf3Scale
     */
    'max': number;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionConfigurationOneOf3Scale
     */
    'max_label'?: string | null;
    /**
     * 
     * @type {APIQuestionScaleIcon}
     * @memberof APIQuestionConfigurationOneOf3Scale
     */
    'icon'?: APIQuestionScaleIcon;
}


/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf4
 */
export interface APIQuestionConfigurationOneOf4 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf4Address}
     * @memberof APIQuestionConfigurationOneOf4
     */
    'address': APIQuestionConfigurationOneOf4Address;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf4Address
 */
export interface APIQuestionConfigurationOneOf4Address {
    /**
     * 
     * @type {APIGenericLocation}
     * @memberof APIQuestionConfigurationOneOf4Address
     */
    'search_centre'?: APIGenericLocation | null;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf5
 */
export interface APIQuestionConfigurationOneOf5 {
    /**
     * 
     * @type {object}
     * @memberof APIQuestionConfigurationOneOf5
     */
    'phone_number': object;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf6
 */
export interface APIQuestionConfigurationOneOf6 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf6FileUpload}
     * @memberof APIQuestionConfigurationOneOf6
     */
    'file_upload': APIQuestionConfigurationOneOf6FileUpload;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf6FileUpload
 */
export interface APIQuestionConfigurationOneOf6FileUpload {
    /**
     * 
     * @type {Array<APIQuestionFileUploadType>}
     * @memberof APIQuestionConfigurationOneOf6FileUpload
     */
    'allowed_types': Array<APIQuestionFileUploadType>;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf7
 */
export interface APIQuestionConfigurationOneOf7 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf7Signature}
     * @memberof APIQuestionConfigurationOneOf7
     */
    'signature': APIQuestionConfigurationOneOf7Signature;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf7Signature
 */
export interface APIQuestionConfigurationOneOf7Signature {
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf7Signature
     */
    'allow_freeform': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf7Signature
     */
    'allow_initial': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf7Signature
     */
    'allow_full_name': boolean;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf8
 */
export interface APIQuestionConfigurationOneOf8 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf8ChoiceMatrix}
     * @memberof APIQuestionConfigurationOneOf8
     */
    'choice_matrix': APIQuestionConfigurationOneOf8ChoiceMatrix;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf8ChoiceMatrix
 */
export interface APIQuestionConfigurationOneOf8ChoiceMatrix {
    /**
     * 
     * @type {Array<string>}
     * @memberof APIQuestionConfigurationOneOf8ChoiceMatrix
     */
    'columns': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APIQuestionConfigurationOneOf8ChoiceMatrix
     */
    'rows': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf8ChoiceMatrix
     */
    'multi_cols': boolean;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf9
 */
export interface APIQuestionConfigurationOneOf9 {
    /**
     * 
     * @type {APIQuestionConfigurationOneOf9DateTime}
     * @memberof APIQuestionConfigurationOneOf9
     */
    'date_time': APIQuestionConfigurationOneOf9DateTime;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOf9DateTime
 */
export interface APIQuestionConfigurationOneOf9DateTime {
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf9DateTime
     */
    'collect_date': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionConfigurationOneOf9DateTime
     */
    'collect_time': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionConfigurationOneOf9DateTime
     */
    'min'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionConfigurationOneOf9DateTime
     */
    'max'?: string | null;
}
/**
 * 
 * @export
 * @interface APIQuestionConfigurationOneOfInfo
 */
export interface APIQuestionConfigurationOneOfInfo {
    /**
     * 
     * @type {string}
     * @memberof APIQuestionConfigurationOneOfInfo
     */
    'background_color'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const APIQuestionFileUploadType = {
    Image: 'Image',
    Video: 'Video',
    Document: 'Document',
    Slideshow: 'Slideshow',
    Spreadsheet: 'Spreadsheet',
    Any: 'Any'
} as const;

export type APIQuestionFileUploadType = typeof APIQuestionFileUploadType[keyof typeof APIQuestionFileUploadType];


/**
 * 
 * @export
 * @interface APIQuestionGroup
 */
export interface APIQuestionGroup {
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroup
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof APIQuestionGroup
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroup
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroup
     */
    'description'?: string | null;
    /**
     * 
     * @type {APIQuestionGroupStepStrategy}
     * @memberof APIQuestionGroup
     */
    'step_strategy': APIQuestionGroupStepStrategy;
}
/**
 * @type APIQuestionGroupStepStrategy
 * @export
 */
export type APIQuestionGroupStepStrategy = APIQuestionGroupStepStrategyOneOf | string;

/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCase
 */
export interface APIQuestionGroupStepStrategyJumpCase {
    /**
     * If Some(uuid) jump to the group with that `uuid`. If None, submit the form.
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCase
     */
    'target_group_id'?: string | null;
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionList}
     * @memberof APIQuestionGroupStepStrategyJumpCase
     */
    'conditions': APIQuestionGroupStepStrategyJumpCaseConditionList;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseCondition
 */
export interface APIQuestionGroupStepStrategyJumpCaseCondition {
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseCondition
     */
    'question_id': string;
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcher}
     * @memberof APIQuestionGroupStepStrategyJumpCaseCondition
     */
    'matcher': APIQuestionGroupStepStrategyJumpCaseConditionMatcher;
}
/**
 * @type APIQuestionGroupStepStrategyJumpCaseConditionList
 * @export
 */
export type APIQuestionGroupStepStrategyJumpCaseConditionList = APIQuestionGroupStepStrategyJumpCaseConditionListOneOf | APIQuestionGroupStepStrategyJumpCaseConditionListOneOf1;

/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionListOneOf
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionListOneOf {
    /**
     * 
     * @type {Array<APIQuestionGroupStepStrategyJumpCaseCondition>}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionListOneOf
     */
    'Or': Array<APIQuestionGroupStepStrategyJumpCaseCondition>;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionListOneOf1
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionListOneOf1 {
    /**
     * 
     * @type {Array<APIQuestionGroupStepStrategyJumpCaseCondition>}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionListOneOf1
     */
    'And': Array<APIQuestionGroupStepStrategyJumpCaseCondition>;
}
/**
 * @type APIQuestionGroupStepStrategyJumpCaseConditionMatcher
 * @export
 */
export type APIQuestionGroupStepStrategyJumpCaseConditionMatcher = APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf | APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1 | APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2 | APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3 | APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4 | APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5 | APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6 | APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7;

/**
 * A single- or multi- choice question exactly matches this _set_ of items (regardless of order)
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOfChoice}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf
     */
    'Choice': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOfChoice;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1 {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1Text}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1
     */
    'Text': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1Text;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1Text
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1Text {
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1Text
     */
    'case_sensitive': boolean;
    /**
     * Checks exact match if false, otherwise checks whether the value is contained
     * @type {boolean}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1Text
     */
    'contains': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf1Text
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2 {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2Scale}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2
     */
    'Scale': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2Scale;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2Scale
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2Scale {
    /**
     * 
     * @type {DirectionOperator}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2Scale
     */
    'direction': DirectionOperator;
    /**
     * 
     * @type {number}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf2Scale
     */
    'value': number;
}


/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3 {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3PhoneNumber}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3
     */
    'PhoneNumber': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3PhoneNumber;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3PhoneNumber
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3PhoneNumber {
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf3PhoneNumber
     */
    'calling_code': string;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4 {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4Address}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4
     */
    'Address': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4Address;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4Address
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4Address {
    /**
     * 
     * @type {APIGenericLocation}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4Address
     */
    'near'?: APIGenericLocation | null;
    /**
     * 
     * @type {number}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4Address
     */
    'near_radius_km'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf4Address
     */
    'in_country'?: string | null;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5 {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5ChoiceMatrix}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5
     */
    'ChoiceMatrix': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5ChoiceMatrix;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5ChoiceMatrix
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5ChoiceMatrix {
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5ChoiceMatrix
     */
    'row': string;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf5ChoiceMatrix
     */
    'column': string;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6 {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6
     */
    'DateTime': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime {
    /**
     * 
     * @type {DirectionOperator}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime
     */
    'direction': DirectionOperator;
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime
     */
    'match_date': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf6DateTime
     */
    'match_time': boolean;
}


/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7 {
    /**
     * 
     * @type {APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7Hidden}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7
     */
    'Hidden': APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7Hidden;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7Hidden
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7Hidden {
    /**
     * 
     * @type {string}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOf7Hidden
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOfChoice
 */
export interface APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOfChoice {
    /**
     * 
     * @type {Array<string>}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOfChoice
     */
    'options': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof APIQuestionGroupStepStrategyJumpCaseConditionMatcherOneOfChoice
     */
    'contains_any': boolean;
}
/**
 * Jump to one of a list of sections, based on which one\'s condition is the first to match
 * @export
 * @interface APIQuestionGroupStepStrategyOneOf
 */
export interface APIQuestionGroupStepStrategyOneOf {
    /**
     * 
     * @type {Array<APIQuestionGroupStepStrategyJumpCase>}
     * @memberof APIQuestionGroupStepStrategyOneOf
     */
    'JumpToSection': Array<APIQuestionGroupStepStrategyJumpCase>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const APIQuestionScaleIcon = {
    Numeric: 'Numeric',
    Stars: 'Stars',
    Hearts: 'Hearts',
    Thumbs: 'Thumbs'
} as const;

export type APIQuestionScaleIcon = typeof APIQuestionScaleIcon[keyof typeof APIQuestionScaleIcon];


/**
 * 
 * @export
 * @enum {string}
 */

export const APIQuestionTextValidator = {
    Email: 'Email',
    Integer: 'Integer',
    Float: 'Float'
} as const;

export type APIQuestionTextValidator = typeof APIQuestionTextValidator[keyof typeof APIQuestionTextValidator];


/**
 * 
 * @export
 * @interface APISubmission
 */
export interface APISubmission {
    /**
     * 
     * @type {string}
     * @memberof APISubmission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APISubmission
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APISubmission
     */
    'for_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof APISubmission
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface APISubmissionCountPerForm
 */
export interface APISubmissionCountPerForm {
    /**
     * 
     * @type {string}
     * @memberof APISubmissionCountPerForm
     */
    'form_id': string;
    /**
     * 
     * @type {string}
     * @memberof APISubmissionCountPerForm
     */
    'team_id': string;
    /**
     * 
     * @type {number}
     * @memberof APISubmissionCountPerForm
     */
    'new_submission_count': number;
}
/**
 * 
 * @export
 * @interface APISubmissionStream
 */
export interface APISubmissionStream {
    /**
     * 
     * @type {string}
     * @memberof APISubmissionStream
     */
    'since'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof APISubmissionStream
     */
    'total': number;
    /**
     * 
     * @type {Array<APISubmission>}
     * @memberof APISubmissionStream
     */
    'new': Array<APISubmission>;
    /**
     * 
     * @type {Array<string>}
     * @memberof APISubmissionStream
     */
    'deleted': Array<string>;
}
/**
 * 
 * @export
 * @interface APITeamAsset
 */
export interface APITeamAsset {
    /**
     * 
     * @type {string}
     * @memberof APITeamAsset
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APITeamAsset
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APITeamAsset
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface APIUserKey
 */
export interface APIUserKey {
    /**
     * 
     * @type {string}
     * @memberof APIUserKey
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKey
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKey
     */
    'key_pem': string;
    /**
     * 
     * @type {boolean}
     * @memberof APIUserKey
     */
    'has_backup': boolean;
    /**
     * 
     * @type {string}
     * @memberof APIUserKey
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKey
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface APIUserKeyWithIdentity
 */
export interface APIUserKeyWithIdentity {
    /**
     * 
     * @type {string}
     * @memberof APIUserKeyWithIdentity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKeyWithIdentity
     */
    'key_fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKeyWithIdentity
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKeyWithIdentity
     */
    'user_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKeyWithIdentity
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof APIUserKeyWithIdentity
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface AddAccessRequest
 */
export interface AddAccessRequest {
    /**
     * 
     * @type {string}
     * @memberof AddAccessRequest
     */
    'for_team_id': string;
}
/**
 * 
 * @export
 * @interface AddTeamMemberRequest
 */
export interface AddTeamMemberRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AddTeamMemberRequest
     */
    'user_ids': Array<string>;
    /**
     * 
     * @type {OrganisationMemberRoleEnum}
     * @memberof AddTeamMemberRequest
     */
    'role': OrganisationMemberRoleEnum;
}


/**
 * 
 * @export
 * @interface AlertResponse
 */
export interface AlertResponse {
    /**
     * 
     * @type {AlertType}
     * @memberof AlertResponse
     */
    'alert_type': AlertType;
    /**
     * 
     * @type {Array<HideContext>}
     * @memberof AlertResponse
     */
    'hide_on': Array<HideContext>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertType = {
    NoActiveKey: 'NoActiveKey'
} as const;

export type AlertType = typeof AlertType[keyof typeof AlertType];


/**
 * 
 * @export
 * @interface AuditLogListRequest
 */
export interface AuditLogListRequest {
    /**
     * 
     * @type {string}
     * @memberof AuditLogListRequest
     */
    'from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListRequest
     */
    'to'?: string | null;
    /**
     * 
     * @type {AuditLogTargetResourceEnum}
     * @memberof AuditLogListRequest
     */
    'resource'?: AuditLogTargetResourceEnum | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AuditLogTargetResourceEnum = {
    AuthSession: 'AuthSession',
    Branding: 'Branding',
    Form: 'Form',
    Organisation: 'Organisation',
    OrganisationAuthConfig: 'OrganisationAuthConfig',
    OrganisationMember: 'OrganisationMember',
    OrganisationSubdomain: 'OrganisationSubdomain',
    Team: 'Team',
    TeamMember: 'TeamMember'
} as const;

export type AuditLogTargetResourceEnum = typeof AuditLogTargetResourceEnum[keyof typeof AuditLogTargetResourceEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const AuditLogVerbEnum = {
    Create: 'Create',
    Delete: 'Delete',
    Read: 'Read',
    Update: 'Update'
} as const;

export type AuditLogVerbEnum = typeof AuditLogVerbEnum[keyof typeof AuditLogVerbEnum];


/**
 * 
 * @export
 * @interface AuthCallbackRequest
 */
export interface AuthCallbackRequest {
    /**
     * The authorization code provided in response from the OIDC provider
     * @type {string}
     * @memberof AuthCallbackRequest
     */
    'auth_code': string;
    /**
     * The nonce provided when starting the auth flow
     * @type {string}
     * @memberof AuthCallbackRequest
     */
    'nonce': string;
    /**
     * The redirect URL set by the client when starting the auth flow
     * @type {string}
     * @memberof AuthCallbackRequest
     */
    'redirect_url': string;
}
/**
 * 
 * @export
 * @interface AuthCallbackResponse
 */
export interface AuthCallbackResponse {
    /**
     * 
     * @type {NewAPIAuthToken}
     * @memberof AuthCallbackResponse
     */
    'token': NewAPIAuthToken;
}
/**
 * 
 * @export
 * @interface AuthTestResponse
 */
export interface AuthTestResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthTestResponse
     */
    'token_id': string;
    /**
     * 
     * @type {APIAdminUser}
     * @memberof AuthTestResponse
     */
    'user': APIAdminUser;
}
/**
 * 
 * @export
 * @interface CancelPlanRequest
 */
export interface CancelPlanRequest {
    /**
     * 
     * @type {CancelPlanRequestReason}
     * @memberof CancelPlanRequest
     */
    'reason': CancelPlanRequestReason;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CancelPlanRequestReason = {
    CustomerService: 'CustomerService',
    LowQuality: 'LowQuality',
    MissingFeatures: 'MissingFeatures',
    Other: 'Other',
    SwitchedService: 'SwitchedService',
    TooComplex: 'TooComplex',
    TooExpensive: 'TooExpensive',
    Unused: 'Unused'
} as const;

export type CancelPlanRequestReason = typeof CancelPlanRequestReason[keyof typeof CancelPlanRequestReason];


/**
 * 
 * @export
 * @interface CreateFormRequest
 */
export interface CreateFormRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFormRequest
     */
    'editor_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFormRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFormRequest
     */
    'in_team': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFormRequest
     */
    'branding_id'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateQuestionRequest
 */
export interface CreateQuestionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateQuestionRequest
     */
    'question_type': string;
    /**
     * 
     * @type {number}
     * @memberof CreateQuestionRequest
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface CreateSubdomainRequest
 */
export interface CreateSubdomainRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateSubdomainRequest
     */
    'subdomain': string;
}
/**
 * 
 * @export
 * @interface CreateTeamRequest
 */
export interface CreateTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password': string;
}
/**
 * @type DecrpytingKey
 * @export
 */
export type DecrpytingKey = DecrpytingKeyOneOf | DecrpytingKeyOneOf1;

/**
 * 
 * @export
 * @interface DecrpytingKeyOneOf
 */
export interface DecrpytingKeyOneOf {
    /**
     * 
     * @type {APIUserKeyWithIdentity}
     * @memberof DecrpytingKeyOneOf
     */
    'Known': APIUserKeyWithIdentity;
}
/**
 * 
 * @export
 * @interface DecrpytingKeyOneOf1
 */
export interface DecrpytingKeyOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof DecrpytingKeyOneOf1
     */
    'Unknown': string;
}
/**
 * 
 * @export
 * @interface DeleteAccessRequest
 */
export interface DeleteAccessRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteAccessRequest
     */
    'for_team_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DirectionOperator = {
    GreaterThan: 'GreaterThan',
    GreaterThanEqualTo: 'GreaterThanEqualTo',
    LessThan: 'LessThan',
    LessThanEqualTo: 'LessThanEqualTo',
    Equal: 'Equal'
} as const;

export type DirectionOperator = typeof DirectionOperator[keyof typeof DirectionOperator];


/**
 * 
 * @export
 * @interface EnrollSecondFactorRequest
 */
export interface EnrollSecondFactorRequest {
    /**
     * 
     * @type {string}
     * @memberof EnrollSecondFactorRequest
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof EnrollSecondFactorRequest
     */
    'nickname': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FormBrandingBorderIntensityEnum = {
    High: 'High',
    Low: 'Low',
    Medium: 'Medium',
    Off: 'Off'
} as const;

export type FormBrandingBorderIntensityEnum = typeof FormBrandingBorderIntensityEnum[keyof typeof FormBrandingBorderIntensityEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const FormBrandingBorderRoundingEnum = {
    Large: 'Large',
    Medium: 'Medium',
    None: 'None',
    Small: 'Small'
} as const;

export type FormBrandingBorderRoundingEnum = typeof FormBrandingBorderRoundingEnum[keyof typeof FormBrandingBorderRoundingEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const FormBrandingFontSizeEnum = {
    Large: 'Large',
    Regular: 'Regular',
    Small: 'Small',
    Tiny: 'Tiny',
    VeryLarge: 'VeryLarge'
} as const;

export type FormBrandingFontSizeEnum = typeof FormBrandingFontSizeEnum[keyof typeof FormBrandingFontSizeEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const FormBrandingSpacingEnum = {
    Comfy: 'Comfy',
    Normal: 'Normal',
    Tight: 'Tight'
} as const;

export type FormBrandingSpacingEnum = typeof FormBrandingSpacingEnum[keyof typeof FormBrandingSpacingEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const HideContext = {
    Induction: 'Induction',
    Keys: 'Keys'
} as const;

export type HideContext = typeof HideContext[keyof typeof HideContext];


/**
 * 
 * @export
 * @interface InductionStatus
 */
export interface InductionStatus {
    /**
     * 
     * @type {boolean}
     * @memberof InductionStatus
     */
    'induction_complete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InductionStatus
     */
    'key_created': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InductionStatus
     */
    'can_create_invite': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InductionStatus
     */
    'invite_created': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InductionStatus
     */
    'form_created': boolean;
}
/**
 * 
 * @export
 * @interface InitiatePlanRequest
 */
export interface InitiatePlanRequest {
    /**
     * 
     * @type {string}
     * @memberof InitiatePlanRequest
     */
    'stripe_plan_price_id': string;
    /**
     * 
     * @type {string}
     * @memberof InitiatePlanRequest
     */
    'success_url': string;
    /**
     * 
     * @type {boolean}
     * @memberof InitiatePlanRequest
     */
    'trial': boolean;
}
/**
 * 
 * @export
 * @interface JoinOrganisationRequest
 */
export interface JoinOrganisationRequest {
    /**
     * 
     * @type {string}
     * @memberof JoinOrganisationRequest
     */
    'invite_id': string;
}
/**
 * 
 * @export
 * @interface NewAPIAuthToken
 */
export interface NewAPIAuthToken {
    /**
     * 
     * @type {string}
     * @memberof NewAPIAuthToken
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NewAPIAuthToken
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof NewAPIAuthToken
     */
    'expires_at': string;
}
/**
 * 
 * @export
 * @interface NewOrganisationInviteRequest
 */
export interface NewOrganisationInviteRequest {
    /**
     * 
     * @type {number}
     * @memberof NewOrganisationInviteRequest
     */
    'expires_in_seconds': number;
    /**
     * 
     * @type {boolean}
     * @memberof NewOrganisationInviteRequest
     */
    'single_use': boolean;
}
/**
 * 
 * @export
 * @interface NewOrganisationRequest
 */
export interface NewOrganisationRequest {
    /**
     * 
     * @type {string}
     * @memberof NewOrganisationRequest
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface NewQuestionGroupRequest
 */
export interface NewQuestionGroupRequest {
    /**
     * 
     * @type {number}
     * @memberof NewQuestionGroupRequest
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionGroupRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionGroupRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface NewTokenRequest
 */
export interface NewTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof NewTokenRequest
     */
    'nickname': string;
    /**
     * 
     * @type {number}
     * @memberof NewTokenRequest
     */
    'expires_in_seconds'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NewTokenRequest
     */
    'short_link'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrganisationMemberRoleEnum = {
    Admin: 'Admin',
    Editor: 'Editor',
    Viewer: 'Viewer'
} as const;

export type OrganisationMemberRoleEnum = typeof OrganisationMemberRoleEnum[keyof typeof OrganisationMemberRoleEnum];


/**
 * 
 * @export
 * @interface PatchOrgMemberRequest
 */
export interface PatchOrgMemberRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchOrgMemberRequest
     */
    'is_admin': boolean;
}
/**
 * 
 * @export
 * @interface PatchOrgRequest
 */
export interface PatchOrgRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchOrgRequest
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface RegisterBackupKeyRequest
 */
export interface RegisterBackupKeyRequest {
    /**
     * PEM-encoded encrypted secret key
     * @type {string}
     * @memberof RegisterBackupKeyRequest
     */
    'key_data'?: string | null;
}
/**
 * 
 * @export
 * @interface RegisterKeyRequest
 */
export interface RegisterKeyRequest {
    /**
     * PEM-encoded public key
     * @type {string}
     * @memberof RegisterKeyRequest
     */
    'key_data': string;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'verification_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface SendPasswordResetRequest
 */
export interface SendPasswordResetRequest {
    /**
     * 
     * @type {string}
     * @memberof SendPasswordResetRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SetSubmissionAutoDeleteRequest
 */
export interface SetSubmissionAutoDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof SetSubmissionAutoDeleteRequest
     */
    'days'?: number | null;
}
/**
 * @type SignInRequest
 * @export
 */
export type SignInRequest = SignInRequestOneOf | SignInRequestOneOf1;

/**
 * 
 * @export
 * @interface SignInRequestOneOf
 */
export interface SignInRequestOneOf {
    /**
     * 
     * @type {SignInRequestOneOfCredentials}
     * @memberof SignInRequestOneOf
     */
    'Credentials': SignInRequestOneOfCredentials;
}
/**
 * 
 * @export
 * @interface SignInRequestOneOf1
 */
export interface SignInRequestOneOf1 {
    /**
     * 
     * @type {SignInRequestOneOf1SecondFactor}
     * @memberof SignInRequestOneOf1
     */
    'SecondFactor': SignInRequestOneOf1SecondFactor;
}
/**
 * 
 * @export
 * @interface SignInRequestOneOf1SecondFactor
 */
export interface SignInRequestOneOf1SecondFactor {
    /**
     * 
     * @type {string}
     * @memberof SignInRequestOneOf1SecondFactor
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof SignInRequestOneOf1SecondFactor
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface SignInRequestOneOfCredentials
 */
export interface SignInRequestOneOfCredentials {
    /**
     * 
     * @type {string}
     * @memberof SignInRequestOneOfCredentials
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInRequestOneOfCredentials
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof SignInRequestOneOfCredentials
     */
    'create_initial_org': boolean;
}
/**
 * @type SignInResponse
 * @export
 */
export type SignInResponse = SignInResponseOneOf | SignInResponseOneOf1;

/**
 * 
 * @export
 * @interface SignInResponseOneOf
 */
export interface SignInResponseOneOf {
    /**
     * 
     * @type {SignInResponseOneOfDone}
     * @memberof SignInResponseOneOf
     */
    'Done': SignInResponseOneOfDone;
}
/**
 * 
 * @export
 * @interface SignInResponseOneOf1
 */
export interface SignInResponseOneOf1 {
    /**
     * 
     * @type {SignInResponseOneOf1SecondFactorRequired}
     * @memberof SignInResponseOneOf1
     */
    'SecondFactorRequired': SignInResponseOneOf1SecondFactorRequired;
}
/**
 * 
 * @export
 * @interface SignInResponseOneOf1SecondFactorRequired
 */
export interface SignInResponseOneOf1SecondFactorRequired {
    /**
     * 
     * @type {string}
     * @memberof SignInResponseOneOf1SecondFactorRequired
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof SignInResponseOneOf1SecondFactorRequired
     */
    'new_org_id'?: string | null;
}
/**
 * 
 * @export
 * @interface SignInResponseOneOfDone
 */
export interface SignInResponseOneOfDone {
    /**
     * 
     * @type {NewAPIAuthToken}
     * @memberof SignInResponseOneOfDone
     */
    'token': NewAPIAuthToken;
    /**
     * 
     * @type {string}
     * @memberof SignInResponseOneOfDone
     */
    'new_org_id'?: string | null;
}
/**
 * 
 * @export
 * @interface StartAuthResponse
 */
export interface StartAuthResponse {
    /**
     * 
     * @type {string}
     * @memberof StartAuthResponse
     */
    'url': string;
    /**
     * Make sure you verify the state returned in the callback is identical to this state value
     * @type {string}
     * @memberof StartAuthResponse
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof StartAuthResponse
     */
    'nonce': string;
}
/**
 * 
 * @export
 * @interface SubmissionCountSinceRequest
 */
export interface SubmissionCountSinceRequest {
    /**
     * 
     * @type {string}
     * @memberof SubmissionCountSinceRequest
     */
    'since': string;
}
/**
 * 
 * @export
 * @interface SubmissionCryptoDetailsResponse
 */
export interface SubmissionCryptoDetailsResponse {
    /**
     * 
     * @type {Array<DecrpytingKey>}
     * @memberof SubmissionCryptoDetailsResponse
     */
    'decrypting_keys': Array<DecrpytingKey>;
}
/**
 * 
 * @export
 * @interface SwitchPlanRequest
 */
export interface SwitchPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof SwitchPlanRequest
     */
    'new_stripe_price_id': string;
}
/**
 * 
 * @export
 * @interface UpdateAdminUserRequest
 */
export interface UpdateAdminUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAdminUserRequest
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface UpdateFormRequest
 */
export interface UpdateFormRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFormRequest
     */
    'editor_name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFormRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateFormRequest
     */
    'branding_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFormRequest
     */
    'notification_email': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateFormRequest
     */
    'notification_webhook_url'?: string | null;
    /**
     * 
     * @type {APIFormEndConfiguration}
     * @memberof UpdateFormRequest
     */
    'end_configuration': APIFormEndConfiguration;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFormRequest
     */
    'enable_captcha': boolean;
}
/**
 * 
 * @export
 * @interface UpdatePaymentMethodRequest
 */
export interface UpdatePaymentMethodRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePaymentMethodRequest
     */
    'redirect_url': string;
}

/**
 * AdminUsersApi - axios parameter creator
 * @export
 */
export const AdminUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpdateAdminUserRequest} updateAdminUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUpdate: async (updateAdminUserRequest: UpdateAdminUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAdminUserRequest' is not null or undefined
            assertParamExists('adminUsersUpdate', 'updateAdminUserRequest', updateAdminUserRequest)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAdminUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminUsersApi - functional programming interface
 * @export
 */
export const AdminUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpdateAdminUserRequest} updateAdminUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersUpdate(updateAdminUserRequest: UpdateAdminUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersUpdate(updateAdminUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminUsersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminUsersApi - factory interface
 * @export
 */
export const AdminUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminUsersApiFp(configuration)
    return {
        /**
         * 
         * @param {UpdateAdminUserRequest} updateAdminUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersUpdate(updateAdminUserRequest: UpdateAdminUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.adminUsersUpdate(updateAdminUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminUsersApi - object-oriented interface
 * @export
 * @class AdminUsersApi
 * @extends {BaseAPI}
 */
export class AdminUsersApi extends BaseAPI {
    /**
     * 
     * @param {UpdateAdminUserRequest} updateAdminUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminUsersUpdate(updateAdminUserRequest: UpdateAdminUserRequest, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminUsersUpdate(updateAdminUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuditLogsApi - axios parameter creator
 * @export
 */
export const AuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {AuditLogListRequest} auditLogListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditList: async (orgId: string, auditLogListRequest: AuditLogListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('auditList', 'orgId', orgId)
            // verify required parameter 'auditLogListRequest' is not null or undefined
            assertParamExists('auditList', 'auditLogListRequest', auditLogListRequest)
            const localVarPath = `/user/me/orgs/{org_id}/audit`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(auditLogListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogsApi - functional programming interface
 * @export
 */
export const AuditLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {AuditLogListRequest} auditLogListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auditList(orgId: string, auditLogListRequest: AuditLogListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIAuditLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auditList(orgId, auditLogListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.auditList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditLogsApi - factory interface
 * @export
 */
export const AuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {AuditLogListRequest} auditLogListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditList(orgId: string, auditLogListRequest: AuditLogListRequest, options?: any): AxiosPromise<Array<APIAuditLogEntry>> {
            return localVarFp.auditList(orgId, auditLogListRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogsApi - object-oriented interface
 * @export
 * @class AuditLogsApi
 * @extends {BaseAPI}
 */
export class AuditLogsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {AuditLogListRequest} auditLogListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public auditList(orgId: string, auditLogListRequest: AuditLogListRequest, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).auditList(orgId, auditLogListRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Process authentication callback  Handle the callback from the OIDC server and generate an API key to be used for future requests
         * @param {string} orgId 
         * @param {AuthCallbackRequest} authCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCallback: async (orgId: string, authCallbackRequest: AuthCallbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('authCallback', 'orgId', orgId)
            // verify required parameter 'authCallbackRequest' is not null or undefined
            assertParamExists('authCallback', 'authCallbackRequest', authCallbackRequest)
            const localVarPath = `/auth/{org_id}/callback`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authCallbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInvalidateToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/tokens/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
         * @param {SignInRequest} signInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignIn: async (xCaptchaResponse: string, signInRequest: SignInRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCaptchaResponse' is not null or undefined
            assertParamExists('authSignIn', 'xCaptchaResponse', xCaptchaResponse)
            // verify required parameter 'signInRequest' is not null or undefined
            assertParamExists('authSignIn', 'signInRequest', signInRequest)
            const localVarPath = `/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCaptchaResponse != null) {
                localVarHeaderParameter['X-Captcha-Response'] = String(xCaptchaResponse);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignUp: async (xCaptchaResponse: string, createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCaptchaResponse' is not null or undefined
            assertParamExists('authSignUp', 'xCaptchaResponse', xCaptchaResponse)
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('authSignUp', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCaptchaResponse != null) {
                localVarHeaderParameter['X-Captcha-Response'] = String(xCaptchaResponse);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start authentication flow  Generate an OIDC URL with the configured provider to start authentication
         * @param {string} orgId 
         * @param {string} redirectUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authStart: async (orgId: string, redirectUrl: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('authStart', 'orgId', orgId)
            // verify required parameter 'redirectUrl' is not null or undefined
            assertParamExists('authStart', 'redirectUrl', redirectUrl)
            const localVarPath = `/auth/{org_id}/start`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirect_url'] = redirectUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test authentication  Checks whether the provided Authorization header is valid and returns the user\'s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} verificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerify: async (verificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verificationId' is not null or undefined
            assertParamExists('authVerify', 'verificationId', verificationId)
            const localVarPath = `/auth/verify/{verification_id}`
                .replace(`{${"verification_id"}}`, encodeURIComponent(String(verificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Process authentication callback  Handle the callback from the OIDC server and generate an API key to be used for future requests
         * @param {string} orgId 
         * @param {AuthCallbackRequest} authCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCallback(orgId: string, authCallbackRequest: AuthCallbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthCallbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCallback(orgId, authCallbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authInvalidateToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authInvalidateToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authInvalidateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
         * @param {SignInRequest} signInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignIn(xCaptchaResponse: string, signInRequest: SignInRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignIn(xCaptchaResponse, signInRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authSignIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignUp(xCaptchaResponse: string, createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignUp(xCaptchaResponse, createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authSignUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start authentication flow  Generate an OIDC URL with the configured provider to start authentication
         * @param {string} orgId 
         * @param {string} redirectUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authStart(orgId: string, redirectUrl: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authStart(orgId, redirectUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test authentication  Checks whether the provided Authorization header is valid and returns the user\'s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTest(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTest(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} verificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerify(verificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerify(verificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authVerify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Process authentication callback  Handle the callback from the OIDC server and generate an API key to be used for future requests
         * @param {string} orgId 
         * @param {AuthCallbackRequest} authCallbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCallback(orgId: string, authCallbackRequest: AuthCallbackRequest, options?: any): AxiosPromise<AuthCallbackResponse> {
            return localVarFp.authCallback(orgId, authCallbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authInvalidateToken(options?: any): AxiosPromise<void> {
            return localVarFp.authInvalidateToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
         * @param {SignInRequest} signInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignIn(xCaptchaResponse: string, signInRequest: SignInRequest, options?: any): AxiosPromise<SignInResponse> {
            return localVarFp.authSignIn(xCaptchaResponse, signInRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignUp(xCaptchaResponse: string, createUserRequest: CreateUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authSignUp(xCaptchaResponse, createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Start authentication flow  Generate an OIDC URL with the configured provider to start authentication
         * @param {string} orgId 
         * @param {string} redirectUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authStart(orgId: string, redirectUrl: string, options?: any): AxiosPromise<StartAuthResponse> {
            return localVarFp.authStart(orgId, redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Test authentication  Checks whether the provided Authorization header is valid and returns the user\'s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTest(options?: any): AxiosPromise<AuthTestResponse> {
            return localVarFp.authTest(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} verificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerify(verificationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.authVerify(verificationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Process authentication callback  Handle the callback from the OIDC server and generate an API key to be used for future requests
     * @param {string} orgId 
     * @param {AuthCallbackRequest} authCallbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authCallback(orgId: string, authCallbackRequest: AuthCallbackRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authCallback(orgId, authCallbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authInvalidateToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authInvalidateToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
     * @param {SignInRequest} signInRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authSignIn(xCaptchaResponse: string, signInRequest: SignInRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authSignIn(xCaptchaResponse, signInRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xCaptchaResponse Response from the Cloudflare Turnstile captcha
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authSignUp(xCaptchaResponse: string, createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authSignUp(xCaptchaResponse, createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start authentication flow  Generate an OIDC URL with the configured provider to start authentication
     * @param {string} orgId 
     * @param {string} redirectUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authStart(orgId: string, redirectUrl: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authStart(orgId, redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test authentication  Checks whether the provided Authorization header is valid and returns the user\'s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authTest(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authTest(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} verificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authVerify(verificationId: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authVerify(verificationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingCustomersApi - axios parameter creator
 * @export
 */
export const BillingCustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingCustomerGet: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingCustomerGet', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/billing/customer`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingCustomerUpdatePaymentMethod: async (orgId: string, updatePaymentMethodRequest: UpdatePaymentMethodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingCustomerUpdatePaymentMethod', 'orgId', orgId)
            // verify required parameter 'updatePaymentMethodRequest' is not null or undefined
            assertParamExists('billingCustomerUpdatePaymentMethod', 'updatePaymentMethodRequest', updatePaymentMethodRequest)
            const localVarPath = `/users/me/orgs/{org_id}/billing/customer/payment_method_update_link`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentMethodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingCustomersApi - functional programming interface
 * @export
 */
export const BillingCustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingCustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingCustomerGet(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIBillingCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingCustomerGet(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingCustomersApi.billingCustomerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingCustomerUpdatePaymentMethod(orgId: string, updatePaymentMethodRequest: UpdatePaymentMethodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingCustomerUpdatePaymentMethod(orgId, updatePaymentMethodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingCustomersApi.billingCustomerUpdatePaymentMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingCustomersApi - factory interface
 * @export
 */
export const BillingCustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingCustomersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingCustomerGet(orgId: string, options?: any): AxiosPromise<APIBillingCustomer> {
            return localVarFp.billingCustomerGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingCustomerUpdatePaymentMethod(orgId: string, updatePaymentMethodRequest: UpdatePaymentMethodRequest, options?: any): AxiosPromise<string> {
            return localVarFp.billingCustomerUpdatePaymentMethod(orgId, updatePaymentMethodRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingCustomersApi - object-oriented interface
 * @export
 * @class BillingCustomersApi
 * @extends {BaseAPI}
 */
export class BillingCustomersApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingCustomersApi
     */
    public billingCustomerGet(orgId: string, options?: RawAxiosRequestConfig) {
        return BillingCustomersApiFp(this.configuration).billingCustomerGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {UpdatePaymentMethodRequest} updatePaymentMethodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingCustomersApi
     */
    public billingCustomerUpdatePaymentMethod(orgId: string, updatePaymentMethodRequest: UpdatePaymentMethodRequest, options?: RawAxiosRequestConfig) {
        return BillingCustomersApiFp(this.configuration).billingCustomerUpdatePaymentMethod(orgId, updatePaymentMethodRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingEntitlementsApi - axios parameter creator
 * @export
 */
export const BillingEntitlementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingEntitlementList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingEntitlementList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/billing/entitlements`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {APIEntitlementRequest} aPIEntitlementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingEntitlementTest: async (orgId: string, aPIEntitlementRequest: APIEntitlementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingEntitlementTest', 'orgId', orgId)
            // verify required parameter 'aPIEntitlementRequest' is not null or undefined
            assertParamExists('billingEntitlementTest', 'aPIEntitlementRequest', aPIEntitlementRequest)
            const localVarPath = `/users/me/orgs/{org_id}/billing/entitlements/test`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIEntitlementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingEntitlementsApi - functional programming interface
 * @export
 */
export const BillingEntitlementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingEntitlementsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingEntitlementList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitlementInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingEntitlementList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingEntitlementsApi.billingEntitlementList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {APIEntitlementRequest} aPIEntitlementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingEntitlementTest(orgId: string, aPIEntitlementRequest: APIEntitlementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingEntitlementTest(orgId, aPIEntitlementRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingEntitlementsApi.billingEntitlementTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingEntitlementsApi - factory interface
 * @export
 */
export const BillingEntitlementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingEntitlementsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingEntitlementList(orgId: string, options?: any): AxiosPromise<APIEntitlementInfo> {
            return localVarFp.billingEntitlementList(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {APIEntitlementRequest} aPIEntitlementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingEntitlementTest(orgId: string, aPIEntitlementRequest: APIEntitlementRequest, options?: any): AxiosPromise<boolean> {
            return localVarFp.billingEntitlementTest(orgId, aPIEntitlementRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingEntitlementsApi - object-oriented interface
 * @export
 * @class BillingEntitlementsApi
 * @extends {BaseAPI}
 */
export class BillingEntitlementsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingEntitlementsApi
     */
    public billingEntitlementList(orgId: string, options?: RawAxiosRequestConfig) {
        return BillingEntitlementsApiFp(this.configuration).billingEntitlementList(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {APIEntitlementRequest} aPIEntitlementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingEntitlementsApi
     */
    public billingEntitlementTest(orgId: string, aPIEntitlementRequest: APIEntitlementRequest, options?: RawAxiosRequestConfig) {
        return BillingEntitlementsApiFp(this.configuration).billingEntitlementTest(orgId, aPIEntitlementRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingInvoicesApi - axios parameter creator
 * @export
 */
export const BillingInvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingInvoiceList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingInvoiceList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/billing/invoices`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} stripeSubscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingInvoicePreview: async (orgId: string, stripeSubscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingInvoicePreview', 'orgId', orgId)
            // verify required parameter 'stripeSubscriptionId' is not null or undefined
            assertParamExists('billingInvoicePreview', 'stripeSubscriptionId', stripeSubscriptionId)
            const localVarPath = `/users/me/orgs/{org_id}/billing/invoices/next`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (stripeSubscriptionId !== undefined) {
                localVarQueryParameter['stripe_subscription_id'] = stripeSubscriptionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingInvoicesApi - functional programming interface
 * @export
 */
export const BillingInvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingInvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingInvoiceList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIBillingInvoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingInvoiceList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingInvoicesApi.billingInvoiceList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} stripeSubscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingInvoicePreview(orgId: string, stripeSubscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIBillingUpcomingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingInvoicePreview(orgId, stripeSubscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingInvoicesApi.billingInvoicePreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingInvoicesApi - factory interface
 * @export
 */
export const BillingInvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingInvoicesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingInvoiceList(orgId: string, options?: any): AxiosPromise<Array<APIBillingInvoice>> {
            return localVarFp.billingInvoiceList(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} stripeSubscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingInvoicePreview(orgId: string, stripeSubscriptionId: string, options?: any): AxiosPromise<APIBillingUpcomingInvoice> {
            return localVarFp.billingInvoicePreview(orgId, stripeSubscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingInvoicesApi - object-oriented interface
 * @export
 * @class BillingInvoicesApi
 * @extends {BaseAPI}
 */
export class BillingInvoicesApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingInvoicesApi
     */
    public billingInvoiceList(orgId: string, options?: RawAxiosRequestConfig) {
        return BillingInvoicesApiFp(this.configuration).billingInvoiceList(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} stripeSubscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingInvoicesApi
     */
    public billingInvoicePreview(orgId: string, stripeSubscriptionId: string, options?: RawAxiosRequestConfig) {
        return BillingInvoicesApiFp(this.configuration).billingInvoicePreview(orgId, stripeSubscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingPlansApi - axios parameter creator
 * @export
 */
export const BillingPlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} stripeSubscriptionId 
         * @param {CancelPlanRequest} cancelPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanCancel: async (orgId: string, stripeSubscriptionId: string, cancelPlanRequest: CancelPlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingPlanCancel', 'orgId', orgId)
            // verify required parameter 'stripeSubscriptionId' is not null or undefined
            assertParamExists('billingPlanCancel', 'stripeSubscriptionId', stripeSubscriptionId)
            // verify required parameter 'cancelPlanRequest' is not null or undefined
            assertParamExists('billingPlanCancel', 'cancelPlanRequest', cancelPlanRequest)
            const localVarPath = `/users/me/orgs/{org_id}/billing/plan/{stripe_subscription_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"stripe_subscription_id"}}`, encodeURIComponent(String(stripeSubscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanGet: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingPlanGet', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/billing/plan`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {InitiatePlanRequest} initiatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanInitiate: async (orgId: string, initiatePlanRequest: InitiatePlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingPlanInitiate', 'orgId', orgId)
            // verify required parameter 'initiatePlanRequest' is not null or undefined
            assertParamExists('billingPlanInitiate', 'initiatePlanRequest', initiatePlanRequest)
            const localVarPath = `/users/me/orgs/{org_id}/billing/plan.initiate`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiatePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency The currency the client is using
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanList: async (currency: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            assertParamExists('billingPlanList', 'currency', currency)
            const localVarPath = `/billing/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {boolean} dryRun 
         * @param {SwitchPlanRequest} switchPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanSwitch: async (orgId: string, dryRun: boolean, switchPlanRequest: SwitchPlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('billingPlanSwitch', 'orgId', orgId)
            // verify required parameter 'dryRun' is not null or undefined
            assertParamExists('billingPlanSwitch', 'dryRun', dryRun)
            // verify required parameter 'switchPlanRequest' is not null or undefined
            assertParamExists('billingPlanSwitch', 'switchPlanRequest', switchPlanRequest)
            const localVarPath = `/users/me/orgs/{org_id}/billing/plan.switch`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(switchPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingPlansApi - functional programming interface
 * @export
 */
export const BillingPlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingPlansApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} stripeSubscriptionId 
         * @param {CancelPlanRequest} cancelPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingPlanCancel(orgId: string, stripeSubscriptionId: string, cancelPlanRequest: CancelPlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingPlanCancel(orgId, stripeSubscriptionId, cancelPlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingPlansApi.billingPlanCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingPlanGet(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIBillingSubscription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingPlanGet(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingPlansApi.billingPlanGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {InitiatePlanRequest} initiatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingPlanInitiate(orgId: string, initiatePlanRequest: InitiatePlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingPlanInitiate(orgId, initiatePlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingPlansApi.billingPlanInitiate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} currency The currency the client is using
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingPlanList(currency: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIBillingPlan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingPlanList(currency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingPlansApi.billingPlanList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {boolean} dryRun 
         * @param {SwitchPlanRequest} switchPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingPlanSwitch(orgId: string, dryRun: boolean, switchPlanRequest: SwitchPlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIBillingUpcomingInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingPlanSwitch(orgId, dryRun, switchPlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingPlansApi.billingPlanSwitch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingPlansApi - factory interface
 * @export
 */
export const BillingPlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingPlansApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} stripeSubscriptionId 
         * @param {CancelPlanRequest} cancelPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanCancel(orgId: string, stripeSubscriptionId: string, cancelPlanRequest: CancelPlanRequest, options?: any): AxiosPromise<void> {
            return localVarFp.billingPlanCancel(orgId, stripeSubscriptionId, cancelPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanGet(orgId: string, options?: any): AxiosPromise<Array<APIBillingSubscription>> {
            return localVarFp.billingPlanGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {InitiatePlanRequest} initiatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanInitiate(orgId: string, initiatePlanRequest: InitiatePlanRequest, options?: any): AxiosPromise<string> {
            return localVarFp.billingPlanInitiate(orgId, initiatePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency The currency the client is using
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanList(currency: string, options?: any): AxiosPromise<Array<APIBillingPlan>> {
            return localVarFp.billingPlanList(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {boolean} dryRun 
         * @param {SwitchPlanRequest} switchPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPlanSwitch(orgId: string, dryRun: boolean, switchPlanRequest: SwitchPlanRequest, options?: any): AxiosPromise<APIBillingUpcomingInvoice> {
            return localVarFp.billingPlanSwitch(orgId, dryRun, switchPlanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingPlansApi - object-oriented interface
 * @export
 * @class BillingPlansApi
 * @extends {BaseAPI}
 */
export class BillingPlansApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} stripeSubscriptionId 
     * @param {CancelPlanRequest} cancelPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPlansApi
     */
    public billingPlanCancel(orgId: string, stripeSubscriptionId: string, cancelPlanRequest: CancelPlanRequest, options?: RawAxiosRequestConfig) {
        return BillingPlansApiFp(this.configuration).billingPlanCancel(orgId, stripeSubscriptionId, cancelPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPlansApi
     */
    public billingPlanGet(orgId: string, options?: RawAxiosRequestConfig) {
        return BillingPlansApiFp(this.configuration).billingPlanGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {InitiatePlanRequest} initiatePlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPlansApi
     */
    public billingPlanInitiate(orgId: string, initiatePlanRequest: InitiatePlanRequest, options?: RawAxiosRequestConfig) {
        return BillingPlansApiFp(this.configuration).billingPlanInitiate(orgId, initiatePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency The currency the client is using
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPlansApi
     */
    public billingPlanList(currency: string, options?: RawAxiosRequestConfig) {
        return BillingPlansApiFp(this.configuration).billingPlanList(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {boolean} dryRun 
     * @param {SwitchPlanRequest} switchPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingPlansApi
     */
    public billingPlanSwitch(orgId: string, dryRun: boolean, switchPlanRequest: SwitchPlanRequest, options?: RawAxiosRequestConfig) {
        return BillingPlansApiFp(this.configuration).billingPlanSwitch(orgId, dryRun, switchPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2FAMethodsApi - axios parameter creator
 * @export
 */
export const Class2FAMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} factorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSecondFactorsDelete: async (factorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'factorId' is not null or undefined
            assertParamExists('userSecondFactorsDelete', 'factorId', factorId)
            const localVarPath = `/users/me/second_factors/{factor_id}`
                .replace(`{${"factor_id"}}`, encodeURIComponent(String(factorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EnrollSecondFactorRequest} enrollSecondFactorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSecondFactorsEnroll: async (enrollSecondFactorRequest: EnrollSecondFactorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'enrollSecondFactorRequest' is not null or undefined
            assertParamExists('userSecondFactorsEnroll', 'enrollSecondFactorRequest', enrollSecondFactorRequest)
            const localVarPath = `/users/me/second_factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enrollSecondFactorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSecondFactorsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/second_factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2FAMethodsApi - functional programming interface
 * @export
 */
export const Class2FAMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2FAMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} factorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSecondFactorsDelete(factorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSecondFactorsDelete(factorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2FAMethodsApi.userSecondFactorsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {EnrollSecondFactorRequest} enrollSecondFactorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSecondFactorsEnroll(enrollSecondFactorRequest: EnrollSecondFactorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSecondFactorsEnroll(enrollSecondFactorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2FAMethodsApi.userSecondFactorsEnroll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSecondFactorsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIAdminUserSecondAuthenticationFactor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSecondFactorsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2FAMethodsApi.userSecondFactorsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2FAMethodsApi - factory interface
 * @export
 */
export const Class2FAMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2FAMethodsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} factorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSecondFactorsDelete(factorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.userSecondFactorsDelete(factorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EnrollSecondFactorRequest} enrollSecondFactorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSecondFactorsEnroll(enrollSecondFactorRequest: EnrollSecondFactorRequest, options?: any): AxiosPromise<string> {
            return localVarFp.userSecondFactorsEnroll(enrollSecondFactorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSecondFactorsList(options?: any): AxiosPromise<Array<APIAdminUserSecondAuthenticationFactor>> {
            return localVarFp.userSecondFactorsList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2FAMethodsApi - object-oriented interface
 * @export
 * @class Class2FAMethodsApi
 * @extends {BaseAPI}
 */
export class Class2FAMethodsApi extends BaseAPI {
    /**
     * 
     * @param {string} factorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAMethodsApi
     */
    public userSecondFactorsDelete(factorId: string, options?: RawAxiosRequestConfig) {
        return Class2FAMethodsApiFp(this.configuration).userSecondFactorsDelete(factorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EnrollSecondFactorRequest} enrollSecondFactorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAMethodsApi
     */
    public userSecondFactorsEnroll(enrollSecondFactorRequest: EnrollSecondFactorRequest, options?: RawAxiosRequestConfig) {
        return Class2FAMethodsApiFp(this.configuration).userSecondFactorsEnroll(enrollSecondFactorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2FAMethodsApi
     */
    public userSecondFactorsList(options?: RawAxiosRequestConfig) {
        return Class2FAMethodsApiFp(this.configuration).userSecondFactorsList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryMetadataApi - axios parameter creator
 * @export
 */
export const CountryMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesListCallingCodes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/countries/calling_codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesListNames: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/countries/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryMetadataApi - functional programming interface
 * @export
 */
export const CountryMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesListCallingCodes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APICountryWithCallingCode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesListCallingCodes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryMetadataApi.countriesListCallingCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesListNames(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APICountryWithISOCode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesListNames(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryMetadataApi.countriesListNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryMetadataApi - factory interface
 * @export
 */
export const CountryMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryMetadataApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesListCallingCodes(options?: any): AxiosPromise<Array<APICountryWithCallingCode>> {
            return localVarFp.countriesListCallingCodes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesListNames(options?: any): AxiosPromise<Array<APICountryWithISOCode>> {
            return localVarFp.countriesListNames(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryMetadataApi - object-oriented interface
 * @export
 * @class CountryMetadataApi
 * @extends {BaseAPI}
 */
export class CountryMetadataApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryMetadataApi
     */
    public countriesListCallingCodes(options?: RawAxiosRequestConfig) {
        return CountryMetadataApiFp(this.configuration).countriesListCallingCodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryMetadataApi
     */
    public countriesListNames(options?: RawAxiosRequestConfig) {
        return CountryMetadataApiFp(this.configuration).countriesListNames(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FillAccessTokensApi - axios parameter creator
 * @export
 */
export const FillAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {NewTokenRequest} newTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillAccessTokensCreate: async (orgId: string, formId: string, newTokenRequest: NewTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('fillAccessTokensCreate', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('fillAccessTokensCreate', 'formId', formId)
            // verify required parameter 'newTokenRequest' is not null or undefined
            assertParamExists('fillAccessTokensCreate', 'newTokenRequest', newTokenRequest)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/fill_access_tokens`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillAccessTokensDelete: async (orgId: string, formId: string, tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('fillAccessTokensDelete', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('fillAccessTokensDelete', 'formId', formId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('fillAccessTokensDelete', 'tokenId', tokenId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/fill_access_tokens/{token_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillAccessTokensList: async (orgId: string, formId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('fillAccessTokensList', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('fillAccessTokensList', 'formId', formId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/fill_access_tokens`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FillAccessTokensApi - functional programming interface
 * @export
 */
export const FillAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FillAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {NewTokenRequest} newTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fillAccessTokensCreate(orgId: string, formId: string, newTokenRequest: NewTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIFillToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fillAccessTokensCreate(orgId, formId, newTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FillAccessTokensApi.fillAccessTokensCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fillAccessTokensDelete(orgId: string, formId: string, tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fillAccessTokensDelete(orgId, formId, tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FillAccessTokensApi.fillAccessTokensDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fillAccessTokensList(orgId: string, formId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIFillToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fillAccessTokensList(orgId, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FillAccessTokensApi.fillAccessTokensList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FillAccessTokensApi - factory interface
 * @export
 */
export const FillAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FillAccessTokensApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {NewTokenRequest} newTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillAccessTokensCreate(orgId: string, formId: string, newTokenRequest: NewTokenRequest, options?: any): AxiosPromise<APIFillToken> {
            return localVarFp.fillAccessTokensCreate(orgId, formId, newTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillAccessTokensDelete(orgId: string, formId: string, tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.fillAccessTokensDelete(orgId, formId, tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillAccessTokensList(orgId: string, formId: string, options?: any): AxiosPromise<Array<APIFillToken>> {
            return localVarFp.fillAccessTokensList(orgId, formId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FillAccessTokensApi - object-oriented interface
 * @export
 * @class FillAccessTokensApi
 * @extends {BaseAPI}
 */
export class FillAccessTokensApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {NewTokenRequest} newTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FillAccessTokensApi
     */
    public fillAccessTokensCreate(orgId: string, formId: string, newTokenRequest: NewTokenRequest, options?: RawAxiosRequestConfig) {
        return FillAccessTokensApiFp(this.configuration).fillAccessTokensCreate(orgId, formId, newTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FillAccessTokensApi
     */
    public fillAccessTokensDelete(orgId: string, formId: string, tokenId: string, options?: RawAxiosRequestConfig) {
        return FillAccessTokensApiFp(this.configuration).fillAccessTokensDelete(orgId, formId, tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FillAccessTokensApi
     */
    public fillAccessTokensList(orgId: string, formId: string, options?: RawAxiosRequestConfig) {
        return FillAccessTokensApiFp(this.configuration).fillAccessTokensList(orgId, formId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FormBrandingsApi - axios parameter creator
 * @export
 */
export const FormBrandingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleFonts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/google-fonts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {AddAccessRequest} addAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingAddAccess: async (orgId: string, teamId: string, brandingId: string, addAccessRequest: AddAccessRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamBrandingAddAccess', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamBrandingAddAccess', 'teamId', teamId)
            // verify required parameter 'brandingId' is not null or undefined
            assertParamExists('organisationTeamBrandingAddAccess', 'brandingId', brandingId)
            // verify required parameter 'addAccessRequest' is not null or undefined
            assertParamExists('organisationTeamBrandingAddAccess', 'addAccessRequest', addAccessRequest)
            const localVarPath = `/users/me/orgs/{org_id}/teams/{team_id}/brandings/{branding_id}/access`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"branding_id"}}`, encodeURIComponent(String(brandingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingCreate: async (orgId: string, teamId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamBrandingCreate', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamBrandingCreate', 'teamId', teamId)
            // verify required parameter 'aPIFormBrandingRequest' is not null or undefined
            assertParamExists('organisationTeamBrandingCreate', 'aPIFormBrandingRequest', aPIFormBrandingRequest)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}/brandings`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIFormBrandingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingDelete: async (orgId: string, teamId: string, brandingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamBrandingDelete', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamBrandingDelete', 'teamId', teamId)
            // verify required parameter 'brandingId' is not null or undefined
            assertParamExists('organisationTeamBrandingDelete', 'brandingId', brandingId)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}/brandings/{branding_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"branding_id"}}`, encodeURIComponent(String(brandingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {DeleteAccessRequest} deleteAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingDeleteAccess: async (orgId: string, teamId: string, brandingId: string, deleteAccessRequest: DeleteAccessRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamBrandingDeleteAccess', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamBrandingDeleteAccess', 'teamId', teamId)
            // verify required parameter 'brandingId' is not null or undefined
            assertParamExists('organisationTeamBrandingDeleteAccess', 'brandingId', brandingId)
            // verify required parameter 'deleteAccessRequest' is not null or undefined
            assertParamExists('organisationTeamBrandingDeleteAccess', 'deleteAccessRequest', deleteAccessRequest)
            const localVarPath = `/users/me/orgs/{org_id}/teams/{_team_id}/brandings/{branding_id}/access`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"_team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"branding_id"}}`, encodeURIComponent(String(brandingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingList: async (orgId: string, teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamBrandingList', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamBrandingList', 'teamId', teamId)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}/brandings`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingListAccess: async (orgId: string, teamId: string, brandingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamBrandingListAccess', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamBrandingListAccess', 'teamId', teamId)
            // verify required parameter 'brandingId' is not null or undefined
            assertParamExists('organisationTeamBrandingListAccess', 'brandingId', brandingId)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}/brandings/{branding_id}/access`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"branding_id"}}`, encodeURIComponent(String(brandingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingPut: async (orgId: string, teamId: string, brandingId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamBrandingPut', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamBrandingPut', 'teamId', teamId)
            // verify required parameter 'brandingId' is not null or undefined
            assertParamExists('organisationTeamBrandingPut', 'brandingId', brandingId)
            // verify required parameter 'aPIFormBrandingRequest' is not null or undefined
            assertParamExists('organisationTeamBrandingPut', 'aPIFormBrandingRequest', aPIFormBrandingRequest)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}/brandings/{branding_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"branding_id"}}`, encodeURIComponent(String(brandingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIFormBrandingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormBrandingsApi - functional programming interface
 * @export
 */
export const FormBrandingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormBrandingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleFonts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleFonts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.googleFonts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {AddAccessRequest} addAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamBrandingAddAccess(orgId: string, teamId: string, brandingId: string, addAccessRequest: AddAccessRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIFormBrandingAccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamBrandingAddAccess(orgId, teamId, brandingId, addAccessRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.organisationTeamBrandingAddAccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamBrandingCreate(orgId: string, teamId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamBrandingCreate(orgId, teamId, aPIFormBrandingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.organisationTeamBrandingCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamBrandingDelete(orgId: string, teamId: string, brandingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamBrandingDelete(orgId, teamId, brandingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.organisationTeamBrandingDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {DeleteAccessRequest} deleteAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamBrandingDeleteAccess(orgId: string, teamId: string, brandingId: string, deleteAccessRequest: DeleteAccessRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamBrandingDeleteAccess(orgId, teamId, brandingId, deleteAccessRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.organisationTeamBrandingDeleteAccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamBrandingList(orgId: string, teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIFormBranding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamBrandingList(orgId, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.organisationTeamBrandingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamBrandingListAccess(orgId: string, teamId: string, brandingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIFormBrandingAccess>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamBrandingListAccess(orgId, teamId, brandingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.organisationTeamBrandingListAccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamBrandingPut(orgId: string, teamId: string, brandingId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamBrandingPut(orgId, teamId, brandingId, aPIFormBrandingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormBrandingsApi.organisationTeamBrandingPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FormBrandingsApi - factory interface
 * @export
 */
export const FormBrandingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormBrandingsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleFonts(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.googleFonts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {AddAccessRequest} addAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingAddAccess(orgId: string, teamId: string, brandingId: string, addAccessRequest: AddAccessRequest, options?: any): AxiosPromise<APIFormBrandingAccess> {
            return localVarFp.organisationTeamBrandingAddAccess(orgId, teamId, brandingId, addAccessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingCreate(orgId: string, teamId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options?: any): AxiosPromise<string> {
            return localVarFp.organisationTeamBrandingCreate(orgId, teamId, aPIFormBrandingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingDelete(orgId: string, teamId: string, brandingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationTeamBrandingDelete(orgId, teamId, brandingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {DeleteAccessRequest} deleteAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingDeleteAccess(orgId: string, teamId: string, brandingId: string, deleteAccessRequest: DeleteAccessRequest, options?: any): AxiosPromise<void> {
            return localVarFp.organisationTeamBrandingDeleteAccess(orgId, teamId, brandingId, deleteAccessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingList(orgId: string, teamId: string, options?: any): AxiosPromise<Array<APIFormBranding>> {
            return localVarFp.organisationTeamBrandingList(orgId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingListAccess(orgId: string, teamId: string, brandingId: string, options?: any): AxiosPromise<Array<APIFormBrandingAccess>> {
            return localVarFp.organisationTeamBrandingListAccess(orgId, teamId, brandingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} brandingId 
         * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamBrandingPut(orgId: string, teamId: string, brandingId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options?: any): AxiosPromise<void> {
            return localVarFp.organisationTeamBrandingPut(orgId, teamId, brandingId, aPIFormBrandingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FormBrandingsApi - object-oriented interface
 * @export
 * @class FormBrandingsApi
 * @extends {BaseAPI}
 */
export class FormBrandingsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public googleFonts(options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).googleFonts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} brandingId 
     * @param {AddAccessRequest} addAccessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public organisationTeamBrandingAddAccess(orgId: string, teamId: string, brandingId: string, addAccessRequest: AddAccessRequest, options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).organisationTeamBrandingAddAccess(orgId, teamId, brandingId, addAccessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public organisationTeamBrandingCreate(orgId: string, teamId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).organisationTeamBrandingCreate(orgId, teamId, aPIFormBrandingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} brandingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public organisationTeamBrandingDelete(orgId: string, teamId: string, brandingId: string, options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).organisationTeamBrandingDelete(orgId, teamId, brandingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} brandingId 
     * @param {DeleteAccessRequest} deleteAccessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public organisationTeamBrandingDeleteAccess(orgId: string, teamId: string, brandingId: string, deleteAccessRequest: DeleteAccessRequest, options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).organisationTeamBrandingDeleteAccess(orgId, teamId, brandingId, deleteAccessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public organisationTeamBrandingList(orgId: string, teamId: string, options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).organisationTeamBrandingList(orgId, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} brandingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public organisationTeamBrandingListAccess(orgId: string, teamId: string, brandingId: string, options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).organisationTeamBrandingListAccess(orgId, teamId, brandingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} brandingId 
     * @param {APIFormBrandingRequest} aPIFormBrandingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormBrandingsApi
     */
    public organisationTeamBrandingPut(orgId: string, teamId: string, brandingId: string, aPIFormBrandingRequest: APIFormBrandingRequest, options?: RawAxiosRequestConfig) {
        return FormBrandingsApiFp(this.configuration).organisationTeamBrandingPut(orgId, teamId, brandingId, aPIFormBrandingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FormsApi - axios parameter creator
 * @export
 */
export const FormsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {CreateFormRequest} createFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsCreate: async (orgId: string, createFormRequest: CreateFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsCreate', 'orgId', orgId)
            // verify required parameter 'createFormRequest' is not null or undefined
            assertParamExists('formsCreate', 'createFormRequest', createFormRequest)
            const localVarPath = `/users/me/orgs/{org_id}/forms`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsDelete: async (orgId: string, formId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsDelete', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsDelete', 'formId', formId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subdomain 
         * @param {string} shortLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsExchangeShortLink: async (subdomain: string, shortLink: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subdomain' is not null or undefined
            assertParamExists('formsExchangeShortLink', 'subdomain', subdomain)
            // verify required parameter 'shortLink' is not null or undefined
            assertParamExists('formsExchangeShortLink', 'shortLink', shortLink)
            const localVarPath = `/fill/short_link/{subdomain}/{short_link}`
                .replace(`{${"subdomain"}}`, encodeURIComponent(String(subdomain)))
                .replace(`{${"short_link"}}`, encodeURIComponent(String(shortLink)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} body 
         * @param {string} [xCaptchaResponse] Response from the Cloudflare Turnstile captcha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsFill: async (orgId: string, formId: string, body: string, xCaptchaResponse?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsFill', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsFill', 'formId', formId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('formsFill', 'body', body)
            const localVarPath = `/fill/orgs/{org_id}/forms/{form_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIFillAccessToken required
            await setApiKeyToObject(localVarQueryParameter, "f", configuration)

            if (xCaptchaResponse != null) {
                localVarHeaderParameter['X-Captcha-Response'] = String(xCaptchaResponse);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGet: async (orgId: string, formId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsGet', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsGet', 'formId', formId)
            const localVarPath = `/users/me/orgs/{_org_id}/forms/{form_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsKeys: async (orgId: string, formId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsKeys', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsKeys', 'formId', formId)
            const localVarPath = `/fill/orgs/{org_id}/forms/{form_id}/keys`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIFillAccessToken required
            await setApiKeyToObject(localVarQueryParameter, "f", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/forms`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsRelocate: async (orgId: string, formId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsRelocate', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsRelocate', 'formId', formId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('formsRelocate', 'body', body)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/location`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {SetSubmissionAutoDeleteRequest} setSubmissionAutoDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsSetAutoDelete: async (orgId: string, formId: string, setSubmissionAutoDeleteRequest: SetSubmissionAutoDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsSetAutoDelete', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsSetAutoDelete', 'formId', formId)
            // verify required parameter 'setSubmissionAutoDeleteRequest' is not null or undefined
            assertParamExists('formsSetAutoDelete', 'setSubmissionAutoDeleteRequest', setSubmissionAutoDeleteRequest)
            const localVarPath = `/users/me/orgs/{_org_id}/forms/{form_id}/auto-delete`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setSubmissionAutoDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {UpdateFormRequest} updateFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsUpdate: async (orgId: string, formId: string, updateFormRequest: UpdateFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsUpdate', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsUpdate', 'formId', formId)
            // verify required parameter 'updateFormRequest' is not null or undefined
            assertParamExists('formsUpdate', 'updateFormRequest', updateFormRequest)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsView: async (orgId: string, formId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('formsView', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('formsView', 'formId', formId)
            const localVarPath = `/fill/orgs/{_org_id}/forms/{form_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIFillAccessToken required
            await setApiKeyToObject(localVarQueryParameter, "f", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormsApi - functional programming interface
 * @export
 */
export const FormsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {CreateFormRequest} createFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsCreate(orgId: string, createFormRequest: CreateFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsCreate(orgId, createFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsDelete(orgId: string, formId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsDelete(orgId, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} subdomain 
         * @param {string} shortLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsExchangeShortLink(subdomain: string, shortLink: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIExchangedShortLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsExchangeShortLink(subdomain, shortLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsExchangeShortLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} body 
         * @param {string} [xCaptchaResponse] Response from the Cloudflare Turnstile captcha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsFill(orgId: string, formId: string, body: string, xCaptchaResponse?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsFill(orgId, formId, body, xCaptchaResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsFill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsGet(orgId: string, formId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsGet(orgId, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsKeys(orgId: string, formId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsKeys(orgId, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIForm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsRelocate(orgId: string, formId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsRelocate(orgId, formId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsRelocate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {SetSubmissionAutoDeleteRequest} setSubmissionAutoDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsSetAutoDelete(orgId: string, formId: string, setSubmissionAutoDeleteRequest: SetSubmissionAutoDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsSetAutoDelete(orgId, formId, setSubmissionAutoDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsSetAutoDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {UpdateFormRequest} updateFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsUpdate(orgId: string, formId: string, updateFormRequest: UpdateFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsUpdate(orgId, formId, updateFormRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formsView(orgId: string, formId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIFormWithQuestions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formsView(orgId, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.formsView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FormsApi - factory interface
 * @export
 */
export const FormsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {CreateFormRequest} createFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsCreate(orgId: string, createFormRequest: CreateFormRequest, options?: any): AxiosPromise<APIForm> {
            return localVarFp.formsCreate(orgId, createFormRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsDelete(orgId: string, formId: string, options?: any): AxiosPromise<void> {
            return localVarFp.formsDelete(orgId, formId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subdomain 
         * @param {string} shortLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsExchangeShortLink(subdomain: string, shortLink: string, options?: any): AxiosPromise<APIExchangedShortLink> {
            return localVarFp.formsExchangeShortLink(subdomain, shortLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} body 
         * @param {string} [xCaptchaResponse] Response from the Cloudflare Turnstile captcha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsFill(orgId: string, formId: string, body: string, xCaptchaResponse?: string, options?: any): AxiosPromise<void> {
            return localVarFp.formsFill(orgId, formId, body, xCaptchaResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsGet(orgId: string, formId: string, options?: any): AxiosPromise<APIForm> {
            return localVarFp.formsGet(orgId, formId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsKeys(orgId: string, formId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.formsKeys(orgId, formId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsList(orgId: string, options?: any): AxiosPromise<Array<APIForm>> {
            return localVarFp.formsList(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsRelocate(orgId: string, formId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.formsRelocate(orgId, formId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {SetSubmissionAutoDeleteRequest} setSubmissionAutoDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsSetAutoDelete(orgId: string, formId: string, setSubmissionAutoDeleteRequest: SetSubmissionAutoDeleteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.formsSetAutoDelete(orgId, formId, setSubmissionAutoDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {UpdateFormRequest} updateFormRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsUpdate(orgId: string, formId: string, updateFormRequest: UpdateFormRequest, options?: any): AxiosPromise<void> {
            return localVarFp.formsUpdate(orgId, formId, updateFormRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formsView(orgId: string, formId: string, options?: any): AxiosPromise<APIFormWithQuestions> {
            return localVarFp.formsView(orgId, formId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FormsApi - object-oriented interface
 * @export
 * @class FormsApi
 * @extends {BaseAPI}
 */
export class FormsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {CreateFormRequest} createFormRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsCreate(orgId: string, createFormRequest: CreateFormRequest, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsCreate(orgId, createFormRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsDelete(orgId: string, formId: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsDelete(orgId, formId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subdomain 
     * @param {string} shortLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsExchangeShortLink(subdomain: string, shortLink: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsExchangeShortLink(subdomain, shortLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} body 
     * @param {string} [xCaptchaResponse] Response from the Cloudflare Turnstile captcha
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsFill(orgId: string, formId: string, body: string, xCaptchaResponse?: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsFill(orgId, formId, body, xCaptchaResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsGet(orgId: string, formId: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsGet(orgId, formId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsKeys(orgId: string, formId: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsKeys(orgId, formId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsList(orgId: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsList(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsRelocate(orgId: string, formId: string, body: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsRelocate(orgId, formId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {SetSubmissionAutoDeleteRequest} setSubmissionAutoDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsSetAutoDelete(orgId: string, formId: string, setSubmissionAutoDeleteRequest: SetSubmissionAutoDeleteRequest, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsSetAutoDelete(orgId, formId, setSubmissionAutoDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {UpdateFormRequest} updateFormRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsUpdate(orgId: string, formId: string, updateFormRequest: UpdateFormRequest, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsUpdate(orgId, formId, updateFormRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formsView(orgId: string, formId: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).formsView(orgId, formId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InductionApi - axios parameter creator
 * @export
 */
export const InductionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inductionAlert: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('inductionAlert', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/induction/alert`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inductionStatus: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('inductionStatus', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/induction`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InductionApi - functional programming interface
 * @export
 */
export const InductionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InductionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inductionAlert(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inductionAlert(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InductionApi.inductionAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inductionStatus(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InductionStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inductionStatus(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InductionApi.inductionStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InductionApi - factory interface
 * @export
 */
export const InductionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InductionApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inductionAlert(orgId: string, options?: any): AxiosPromise<AlertResponse> {
            return localVarFp.inductionAlert(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inductionStatus(orgId: string, options?: any): AxiosPromise<InductionStatus> {
            return localVarFp.inductionStatus(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InductionApi - object-oriented interface
 * @export
 * @class InductionApi
 * @extends {BaseAPI}
 */
export class InductionApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InductionApi
     */
    public inductionAlert(orgId: string, options?: RawAxiosRequestConfig) {
        return InductionApiFp(this.configuration).inductionAlert(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InductionApi
     */
    public inductionStatus(orgId: string, options?: RawAxiosRequestConfig) {
        return InductionApiFp(this.configuration).inductionStatus(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.metaHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaHealth(options?: any): AxiosPromise<string> {
            return localVarFp.metaHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaHealth(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationAuthenticationConfigurationApi - axios parameter creator
 * @export
 */
export const OrganisationAuthenticationConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigGet: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationAuthConfigGet', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{_org_id}/auth_config`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {APIOrganisationAuthConfig} aPIOrganisationAuthConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigPut: async (orgId: string, aPIOrganisationAuthConfig: APIOrganisationAuthConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationAuthConfigPut', 'orgId', orgId)
            // verify required parameter 'aPIOrganisationAuthConfig' is not null or undefined
            assertParamExists('organisationAuthConfigPut', 'aPIOrganisationAuthConfig', aPIOrganisationAuthConfig)
            const localVarPath = `/users/me/orgs/{org_id}/auth_config`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIOrganisationAuthConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationAuthenticationConfigurationApi - functional programming interface
 * @export
 */
export const OrganisationAuthenticationConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationAuthenticationConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationAuthConfigGet(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOrganisationAuthConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationAuthConfigGet(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationAuthenticationConfigurationApi.organisationAuthConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {APIOrganisationAuthConfig} aPIOrganisationAuthConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationAuthConfigPut(orgId: string, aPIOrganisationAuthConfig: APIOrganisationAuthConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationAuthConfigPut(orgId, aPIOrganisationAuthConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationAuthenticationConfigurationApi.organisationAuthConfigPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationAuthenticationConfigurationApi - factory interface
 * @export
 */
export const OrganisationAuthenticationConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationAuthenticationConfigurationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigGet(orgId: string, options?: any): AxiosPromise<APIOrganisationAuthConfig> {
            return localVarFp.organisationAuthConfigGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {APIOrganisationAuthConfig} aPIOrganisationAuthConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigPut(orgId: string, aPIOrganisationAuthConfig: APIOrganisationAuthConfig, options?: any): AxiosPromise<void> {
            return localVarFp.organisationAuthConfigPut(orgId, aPIOrganisationAuthConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationAuthenticationConfigurationApi - object-oriented interface
 * @export
 * @class OrganisationAuthenticationConfigurationApi
 * @extends {BaseAPI}
 */
export class OrganisationAuthenticationConfigurationApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationAuthenticationConfigurationApi
     */
    public organisationAuthConfigGet(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationAuthenticationConfigurationApiFp(this.configuration).organisationAuthConfigGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {APIOrganisationAuthConfig} aPIOrganisationAuthConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationAuthenticationConfigurationApi
     */
    public organisationAuthConfigPut(orgId: string, aPIOrganisationAuthConfig: APIOrganisationAuthConfig, options?: RawAxiosRequestConfig) {
        return OrganisationAuthenticationConfigurationApiFp(this.configuration).organisationAuthConfigPut(orgId, aPIOrganisationAuthConfig, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationAuthenticationTeamMappingsApi - axios parameter creator
 * @export
 */
export const OrganisationAuthenticationTeamMappingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {APIOrganisationAuthTeamMappingRequest} aPIOrganisationAuthTeamMappingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigMappingsCreate: async (orgId: string, aPIOrganisationAuthTeamMappingRequest: APIOrganisationAuthTeamMappingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationAuthConfigMappingsCreate', 'orgId', orgId)
            // verify required parameter 'aPIOrganisationAuthTeamMappingRequest' is not null or undefined
            assertParamExists('organisationAuthConfigMappingsCreate', 'aPIOrganisationAuthTeamMappingRequest', aPIOrganisationAuthTeamMappingRequest)
            const localVarPath = `/users/me/orgs/{org_id}/auth_config/mappings`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIOrganisationAuthTeamMappingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} mappingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigMappingsDelete: async (orgId: string, mappingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationAuthConfigMappingsDelete', 'orgId', orgId)
            // verify required parameter 'mappingId' is not null or undefined
            assertParamExists('organisationAuthConfigMappingsDelete', 'mappingId', mappingId)
            const localVarPath = `/users/me/orgs/{org_id}/auth_config/mappings/{mapping_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"mapping_id"}}`, encodeURIComponent(String(mappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigMappingsList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationAuthConfigMappingsList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{_org_id}/auth_config/mappings`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationAuthenticationTeamMappingsApi - functional programming interface
 * @export
 */
export const OrganisationAuthenticationTeamMappingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationAuthenticationTeamMappingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {APIOrganisationAuthTeamMappingRequest} aPIOrganisationAuthTeamMappingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationAuthConfigMappingsCreate(orgId: string, aPIOrganisationAuthTeamMappingRequest: APIOrganisationAuthTeamMappingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationAuthConfigMappingsCreate(orgId, aPIOrganisationAuthTeamMappingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationAuthenticationTeamMappingsApi.organisationAuthConfigMappingsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} mappingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationAuthConfigMappingsDelete(orgId: string, mappingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationAuthConfigMappingsDelete(orgId, mappingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationAuthenticationTeamMappingsApi.organisationAuthConfigMappingsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationAuthConfigMappingsList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIOrganisationAuthTeamMapping>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationAuthConfigMappingsList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationAuthenticationTeamMappingsApi.organisationAuthConfigMappingsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationAuthenticationTeamMappingsApi - factory interface
 * @export
 */
export const OrganisationAuthenticationTeamMappingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationAuthenticationTeamMappingsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {APIOrganisationAuthTeamMappingRequest} aPIOrganisationAuthTeamMappingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigMappingsCreate(orgId: string, aPIOrganisationAuthTeamMappingRequest: APIOrganisationAuthTeamMappingRequest, options?: any): AxiosPromise<string> {
            return localVarFp.organisationAuthConfigMappingsCreate(orgId, aPIOrganisationAuthTeamMappingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} mappingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigMappingsDelete(orgId: string, mappingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationAuthConfigMappingsDelete(orgId, mappingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationAuthConfigMappingsList(orgId: string, options?: any): AxiosPromise<Array<APIOrganisationAuthTeamMapping>> {
            return localVarFp.organisationAuthConfigMappingsList(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationAuthenticationTeamMappingsApi - object-oriented interface
 * @export
 * @class OrganisationAuthenticationTeamMappingsApi
 * @extends {BaseAPI}
 */
export class OrganisationAuthenticationTeamMappingsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {APIOrganisationAuthTeamMappingRequest} aPIOrganisationAuthTeamMappingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationAuthenticationTeamMappingsApi
     */
    public organisationAuthConfigMappingsCreate(orgId: string, aPIOrganisationAuthTeamMappingRequest: APIOrganisationAuthTeamMappingRequest, options?: RawAxiosRequestConfig) {
        return OrganisationAuthenticationTeamMappingsApiFp(this.configuration).organisationAuthConfigMappingsCreate(orgId, aPIOrganisationAuthTeamMappingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} mappingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationAuthenticationTeamMappingsApi
     */
    public organisationAuthConfigMappingsDelete(orgId: string, mappingId: string, options?: RawAxiosRequestConfig) {
        return OrganisationAuthenticationTeamMappingsApiFp(this.configuration).organisationAuthConfigMappingsDelete(orgId, mappingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationAuthenticationTeamMappingsApi
     */
    public organisationAuthConfigMappingsList(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationAuthenticationTeamMappingsApiFp(this.configuration).organisationAuthConfigMappingsList(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationInvitesApi - axios parameter creator
 * @export
 */
export const OrganisationInvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {NewOrganisationInviteRequest} newOrganisationInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesCreate: async (orgId: string, newOrganisationInviteRequest: NewOrganisationInviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationInvitesCreate', 'orgId', orgId)
            // verify required parameter 'newOrganisationInviteRequest' is not null or undefined
            assertParamExists('organisationInvitesCreate', 'newOrganisationInviteRequest', newOrganisationInviteRequest)
            const localVarPath = `/users/me/orgs/{org_id}/invites`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newOrganisationInviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesDelete: async (orgId: string, inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationInvitesDelete', 'orgId', orgId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('organisationInvitesDelete', 'inviteId', inviteId)
            const localVarPath = `/users/me/orgs/{org_id}/invites/{invite_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationInvitesList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/invites`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesPreview: async (orgId: string, inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationInvitesPreview', 'orgId', orgId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('organisationInvitesPreview', 'inviteId', inviteId)
            const localVarPath = `/users/me/orgs/{org_id}/invites/{invite_id}/preview`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationInvitesApi - functional programming interface
 * @export
 */
export const OrganisationInvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationInvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {NewOrganisationInviteRequest} newOrganisationInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationInvitesCreate(orgId: string, newOrganisationInviteRequest: NewOrganisationInviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOrganisationInvite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationInvitesCreate(orgId, newOrganisationInviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationInvitesApi.organisationInvitesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationInvitesDelete(orgId: string, inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationInvitesDelete(orgId, inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationInvitesApi.organisationInvitesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationInvitesList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIOrganisationInvite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationInvitesList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationInvitesApi.organisationInvitesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationInvitesPreview(orgId: string, inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOrganisationInvitePreview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationInvitesPreview(orgId, inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationInvitesApi.organisationInvitesPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationInvitesApi - factory interface
 * @export
 */
export const OrganisationInvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationInvitesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {NewOrganisationInviteRequest} newOrganisationInviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesCreate(orgId: string, newOrganisationInviteRequest: NewOrganisationInviteRequest, options?: any): AxiosPromise<APIOrganisationInvite> {
            return localVarFp.organisationInvitesCreate(orgId, newOrganisationInviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesDelete(orgId: string, inviteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationInvitesDelete(orgId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesList(orgId: string, options?: any): AxiosPromise<Array<APIOrganisationInvite>> {
            return localVarFp.organisationInvitesList(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} inviteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationInvitesPreview(orgId: string, inviteId: string, options?: any): AxiosPromise<APIOrganisationInvitePreview> {
            return localVarFp.organisationInvitesPreview(orgId, inviteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationInvitesApi - object-oriented interface
 * @export
 * @class OrganisationInvitesApi
 * @extends {BaseAPI}
 */
export class OrganisationInvitesApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {NewOrganisationInviteRequest} newOrganisationInviteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationInvitesApi
     */
    public organisationInvitesCreate(orgId: string, newOrganisationInviteRequest: NewOrganisationInviteRequest, options?: RawAxiosRequestConfig) {
        return OrganisationInvitesApiFp(this.configuration).organisationInvitesCreate(orgId, newOrganisationInviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} inviteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationInvitesApi
     */
    public organisationInvitesDelete(orgId: string, inviteId: string, options?: RawAxiosRequestConfig) {
        return OrganisationInvitesApiFp(this.configuration).organisationInvitesDelete(orgId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationInvitesApi
     */
    public organisationInvitesList(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationInvitesApiFp(this.configuration).organisationInvitesList(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} inviteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationInvitesApi
     */
    public organisationInvitesPreview(orgId: string, inviteId: string, options?: RawAxiosRequestConfig) {
        return OrganisationInvitesApiFp(this.configuration).organisationInvitesPreview(orgId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationKeysApi - axios parameter creator
 * @export
 */
export const OrganisationKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgKeysList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgKeysList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/keys/all`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationKeysApi - functional programming interface
 * @export
 */
export const OrganisationKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgKeysList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIUserKeyWithIdentity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgKeysList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationKeysApi.orgKeysList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationKeysApi - factory interface
 * @export
 */
export const OrganisationKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationKeysApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgKeysList(orgId: string, options?: any): AxiosPromise<Array<APIUserKeyWithIdentity>> {
            return localVarFp.orgKeysList(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationKeysApi - object-oriented interface
 * @export
 * @class OrganisationKeysApi
 * @extends {BaseAPI}
 */
export class OrganisationKeysApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationKeysApi
     */
    public orgKeysList(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationKeysApiFp(this.configuration).orgKeysList(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationMembersApi - axios parameter creator
 * @export
 */
export const OrganisationMembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersAmIAdmin: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationMembersAmIAdmin', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/am-i-admin`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersDelete: async (orgId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationMembersDelete', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('organisationMembersDelete', 'userId', userId)
            const localVarPath = `/users/me/orgs/{org_id}/members/{user_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {JoinOrganisationRequest} joinOrganisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersJoin: async (orgId: string, joinOrganisationRequest: JoinOrganisationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationMembersJoin', 'orgId', orgId)
            // verify required parameter 'joinOrganisationRequest' is not null or undefined
            assertParamExists('organisationMembersJoin', 'joinOrganisationRequest', joinOrganisationRequest)
            const localVarPath = `/users/me/orgs/{org_id}/members`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinOrganisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationMembersList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/members`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {PatchOrgMemberRequest} patchOrgMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersPatch: async (orgId: string, userId: string, patchOrgMemberRequest: PatchOrgMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationMembersPatch', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('organisationMembersPatch', 'userId', userId)
            // verify required parameter 'patchOrgMemberRequest' is not null or undefined
            assertParamExists('organisationMembersPatch', 'patchOrgMemberRequest', patchOrgMemberRequest)
            const localVarPath = `/users/me/orgs/{org_id}/members/{user_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOrgMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationMembersApi - functional programming interface
 * @export
 */
export const OrganisationMembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationMembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationMembersAmIAdmin(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationMembersAmIAdmin(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationMembersApi.organisationMembersAmIAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationMembersDelete(orgId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationMembersDelete(orgId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationMembersApi.organisationMembersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {JoinOrganisationRequest} joinOrganisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationMembersJoin(orgId: string, joinOrganisationRequest: JoinOrganisationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationMembersJoin(orgId, joinOrganisationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationMembersApi.organisationMembersJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationMembersList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIOrgMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationMembersList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationMembersApi.organisationMembersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {PatchOrgMemberRequest} patchOrgMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationMembersPatch(orgId: string, userId: string, patchOrgMemberRequest: PatchOrgMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationMembersPatch(orgId, userId, patchOrgMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationMembersApi.organisationMembersPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationMembersApi - factory interface
 * @export
 */
export const OrganisationMembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationMembersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersAmIAdmin(orgId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.organisationMembersAmIAdmin(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersDelete(orgId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationMembersDelete(orgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {JoinOrganisationRequest} joinOrganisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersJoin(orgId: string, joinOrganisationRequest: JoinOrganisationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.organisationMembersJoin(orgId, joinOrganisationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersList(orgId: string, options?: any): AxiosPromise<Array<APIOrgMember>> {
            return localVarFp.organisationMembersList(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} userId 
         * @param {PatchOrgMemberRequest} patchOrgMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationMembersPatch(orgId: string, userId: string, patchOrgMemberRequest: PatchOrgMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.organisationMembersPatch(orgId, userId, patchOrgMemberRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationMembersApi - object-oriented interface
 * @export
 * @class OrganisationMembersApi
 * @extends {BaseAPI}
 */
export class OrganisationMembersApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationMembersApi
     */
    public organisationMembersAmIAdmin(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationMembersApiFp(this.configuration).organisationMembersAmIAdmin(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationMembersApi
     */
    public organisationMembersDelete(orgId: string, userId: string, options?: RawAxiosRequestConfig) {
        return OrganisationMembersApiFp(this.configuration).organisationMembersDelete(orgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {JoinOrganisationRequest} joinOrganisationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationMembersApi
     */
    public organisationMembersJoin(orgId: string, joinOrganisationRequest: JoinOrganisationRequest, options?: RawAxiosRequestConfig) {
        return OrganisationMembersApiFp(this.configuration).organisationMembersJoin(orgId, joinOrganisationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationMembersApi
     */
    public organisationMembersList(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationMembersApiFp(this.configuration).organisationMembersList(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} userId 
     * @param {PatchOrgMemberRequest} patchOrgMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationMembersApi
     */
    public organisationMembersPatch(orgId: string, userId: string, patchOrgMemberRequest: PatchOrgMemberRequest, options?: RawAxiosRequestConfig) {
        return OrganisationMembersApiFp(this.configuration).organisationMembersPatch(orgId, userId, patchOrgMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationTeamMembersApi - axios parameter creator
 * @export
 */
export const OrganisationTeamMembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {AddTeamMemberRequest} addTeamMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersAdd: async (orgId: string, teamId: string, addTeamMemberRequest: AddTeamMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamMembersAdd', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamMembersAdd', 'teamId', teamId)
            // verify required parameter 'addTeamMemberRequest' is not null or undefined
            assertParamExists('organisationTeamMembersAdd', 'addTeamMemberRequest', addTeamMemberRequest)
            const localVarPath = `/users/me/orgs/{org_id}/teams/{team_id}/members`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTeamMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} memberUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersDelete: async (orgId: string, teamId: string, memberUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamMembersDelete', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamMembersDelete', 'teamId', teamId)
            // verify required parameter 'memberUserId' is not null or undefined
            assertParamExists('organisationTeamMembersDelete', 'memberUserId', memberUserId)
            const localVarPath = `/users/me/orgs/{org_id}/teams/{team_id}/members/{member_user_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"member_user_id"}}`, encodeURIComponent(String(memberUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersList: async (orgId: string, teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamMembersList', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamMembersList', 'teamId', teamId)
            const localVarPath = `/users/me/orgs/{org_id}/teams/{team_id}/members`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} memberUserId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersPatch: async (orgId: string, teamId: string, memberUserId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamMembersPatch', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamMembersPatch', 'teamId', teamId)
            // verify required parameter 'memberUserId' is not null or undefined
            assertParamExists('organisationTeamMembersPatch', 'memberUserId', memberUserId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('organisationTeamMembersPatch', 'body', body)
            const localVarPath = `/users/me/orgs/{org_id}/teams/{team_id}/members/{member_user_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"member_user_id"}}`, encodeURIComponent(String(memberUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationTeamMembersApi - functional programming interface
 * @export
 */
export const OrganisationTeamMembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationTeamMembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {AddTeamMemberRequest} addTeamMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamMembersAdd(orgId: string, teamId: string, addTeamMemberRequest: AddTeamMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamMembersAdd(orgId, teamId, addTeamMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamMembersApi.organisationTeamMembersAdd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} memberUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamMembersDelete(orgId: string, teamId: string, memberUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamMembersDelete(orgId, teamId, memberUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamMembersApi.organisationTeamMembersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamMembersList(orgId: string, teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIOrganisationTeamMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamMembersList(orgId, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamMembersApi.organisationTeamMembersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} memberUserId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamMembersPatch(orgId: string, teamId: string, memberUserId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamMembersPatch(orgId, teamId, memberUserId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamMembersApi.organisationTeamMembersPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationTeamMembersApi - factory interface
 * @export
 */
export const OrganisationTeamMembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationTeamMembersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {AddTeamMemberRequest} addTeamMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersAdd(orgId: string, teamId: string, addTeamMemberRequest: AddTeamMemberRequest, options?: any): AxiosPromise<void> {
            return localVarFp.organisationTeamMembersAdd(orgId, teamId, addTeamMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} memberUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersDelete(orgId: string, teamId: string, memberUserId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationTeamMembersDelete(orgId, teamId, memberUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersList(orgId: string, teamId: string, options?: any): AxiosPromise<Array<APIOrganisationTeamMember>> {
            return localVarFp.organisationTeamMembersList(orgId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} memberUserId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamMembersPatch(orgId: string, teamId: string, memberUserId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationTeamMembersPatch(orgId, teamId, memberUserId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationTeamMembersApi - object-oriented interface
 * @export
 * @class OrganisationTeamMembersApi
 * @extends {BaseAPI}
 */
export class OrganisationTeamMembersApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {AddTeamMemberRequest} addTeamMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamMembersApi
     */
    public organisationTeamMembersAdd(orgId: string, teamId: string, addTeamMemberRequest: AddTeamMemberRequest, options?: RawAxiosRequestConfig) {
        return OrganisationTeamMembersApiFp(this.configuration).organisationTeamMembersAdd(orgId, teamId, addTeamMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} memberUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamMembersApi
     */
    public organisationTeamMembersDelete(orgId: string, teamId: string, memberUserId: string, options?: RawAxiosRequestConfig) {
        return OrganisationTeamMembersApiFp(this.configuration).organisationTeamMembersDelete(orgId, teamId, memberUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamMembersApi
     */
    public organisationTeamMembersList(orgId: string, teamId: string, options?: RawAxiosRequestConfig) {
        return OrganisationTeamMembersApiFp(this.configuration).organisationTeamMembersList(orgId, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} memberUserId 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamMembersApi
     */
    public organisationTeamMembersPatch(orgId: string, teamId: string, memberUserId: string, body: string, options?: RawAxiosRequestConfig) {
        return OrganisationTeamMembersApiFp(this.configuration).organisationTeamMembersPatch(orgId, teamId, memberUserId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationTeamsApi - axios parameter creator
 * @export
 */
export const OrganisationTeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsCreate: async (orgId: string, createTeamRequest: CreateTeamRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamsCreate', 'orgId', orgId)
            // verify required parameter 'createTeamRequest' is not null or undefined
            assertParamExists('organisationTeamsCreate', 'createTeamRequest', createTeamRequest)
            const localVarPath = `/users/me/orgs/{org_id}/teams`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsDelete: async (orgId: string, teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamsDelete', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamsDelete', 'teamId', teamId)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Admin_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsGet: async (orgId: string, teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamsGet', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamsGet', 'teamId', teamId)
            const localVarPath = `/users/me/orgs/{org_id}/teams/{team_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsList: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamsList', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/teams`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsListMy: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamsListMy', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}/teams.my`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationTeamsApi - functional programming interface
 * @export
 */
export const OrganisationTeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationTeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamsCreate(orgId: string, createTeamRequest: CreateTeamRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamsCreate(orgId, createTeamRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamsApi.organisationTeamsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamsDelete(orgId: string, teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamsDelete(orgId, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamsApi.organisationTeamsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamsGet(orgId: string, teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOrganisationTeam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamsGet(orgId, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamsApi.organisationTeamsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamsList(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIOrganisationTeam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamsList(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamsApi.organisationTeamsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamsListMy(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIOrganisationTeamMembership>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamsListMy(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationTeamsApi.organisationTeamsListMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationTeamsApi - factory interface
 * @export
 */
export const OrganisationTeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationTeamsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {CreateTeamRequest} createTeamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsCreate(orgId: string, createTeamRequest: CreateTeamRequest, options?: any): AxiosPromise<string> {
            return localVarFp.organisationTeamsCreate(orgId, createTeamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsDelete(orgId: string, teamId: string, options?: any): AxiosPromise<void> {
            return localVarFp.organisationTeamsDelete(orgId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsGet(orgId: string, teamId: string, options?: any): AxiosPromise<APIOrganisationTeam> {
            return localVarFp.organisationTeamsGet(orgId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsList(orgId: string, options?: any): AxiosPromise<Array<APIOrganisationTeam>> {
            return localVarFp.organisationTeamsList(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamsListMy(orgId: string, options?: any): AxiosPromise<Array<APIOrganisationTeamMembership>> {
            return localVarFp.organisationTeamsListMy(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationTeamsApi - object-oriented interface
 * @export
 * @class OrganisationTeamsApi
 * @extends {BaseAPI}
 */
export class OrganisationTeamsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {CreateTeamRequest} createTeamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamsApi
     */
    public organisationTeamsCreate(orgId: string, createTeamRequest: CreateTeamRequest, options?: RawAxiosRequestConfig) {
        return OrganisationTeamsApiFp(this.configuration).organisationTeamsCreate(orgId, createTeamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamsApi
     */
    public organisationTeamsDelete(orgId: string, teamId: string, options?: RawAxiosRequestConfig) {
        return OrganisationTeamsApiFp(this.configuration).organisationTeamsDelete(orgId, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamsApi
     */
    public organisationTeamsGet(orgId: string, teamId: string, options?: RawAxiosRequestConfig) {
        return OrganisationTeamsApiFp(this.configuration).organisationTeamsGet(orgId, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamsApi
     */
    public organisationTeamsList(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationTeamsApiFp(this.configuration).organisationTeamsList(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationTeamsApi
     */
    public organisationTeamsListMy(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationTeamsApiFp(this.configuration).organisationTeamsListMy(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganisationsApi - axios parameter creator
 * @export
 */
export const OrganisationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewOrganisationRequest} newOrganisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsCreate: async (newOrganisationRequest: NewOrganisationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newOrganisationRequest' is not null or undefined
            assertParamExists('orgsCreate', 'newOrganisationRequest', newOrganisationRequest)
            const localVarPath = `/users/me/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newOrganisationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {CreateSubdomainRequest} createSubdomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsCreateSubdomain: async (orgId: string, createSubdomainRequest: CreateSubdomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsCreateSubdomain', 'orgId', orgId)
            // verify required parameter 'createSubdomainRequest' is not null or undefined
            assertParamExists('orgsCreateSubdomain', 'createSubdomainRequest', createSubdomainRequest)
            const localVarPath = `/user/me/orgs/{org_id}/subdomain`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubdomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsDelete: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsDelete', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsGet', 'orgId', orgId)
            const localVarPath = `/users/me/orgs/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organisation  List all the organisations that the authenticated user is a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {PatchOrgRequest} patchOrgRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsRename: async (orgId: string, patchOrgRequest: PatchOrgRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsRename', 'orgId', orgId)
            // verify required parameter 'patchOrgRequest' is not null or undefined
            assertParamExists('orgsRename', 'patchOrgRequest', patchOrgRequest)
            const localVarPath = `/users/me/orgs/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOrgRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsResolveSubdomain: async (subdomain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subdomain' is not null or undefined
            assertParamExists('orgsResolveSubdomain', 'subdomain', subdomain)
            const localVarPath = `/orgs/for-subdomain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subdomain !== undefined) {
                localVarQueryParameter['subdomain'] = subdomain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationsApi - functional programming interface
 * @export
 */
export const OrganisationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganisationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NewOrganisationRequest} newOrganisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsCreate(newOrganisationRequest: NewOrganisationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsCreate(newOrganisationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.orgsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {CreateSubdomainRequest} createSubdomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsCreateSubdomain(orgId: string, createSubdomainRequest: CreateSubdomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsCreateSubdomain(orgId, createSubdomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.orgsCreateSubdomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsDelete(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsDelete(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.orgsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOrganisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.orgsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List organisation  List all the organisations that the authenticated user is a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIOrganisation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.orgsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {PatchOrgRequest} patchOrgRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsRename(orgId: string, patchOrgRequest: PatchOrgRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsRename(orgId, patchOrgRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.orgsRename']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsResolveSubdomain(subdomain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsResolveSubdomain(subdomain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganisationsApi.orgsResolveSubdomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganisationsApi - factory interface
 * @export
 */
export const OrganisationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganisationsApiFp(configuration)
    return {
        /**
         * 
         * @param {NewOrganisationRequest} newOrganisationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsCreate(newOrganisationRequest: NewOrganisationRequest, options?: any): AxiosPromise<string> {
            return localVarFp.orgsCreate(newOrganisationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {CreateSubdomainRequest} createSubdomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsCreateSubdomain(orgId: string, createSubdomainRequest: CreateSubdomainRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsCreateSubdomain(orgId, createSubdomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsDelete(orgId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsDelete(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(orgId: string, options?: any): AxiosPromise<APIOrganisation> {
            return localVarFp.orgsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organisation  List all the organisations that the authenticated user is a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsList(options?: any): AxiosPromise<Array<APIOrganisation>> {
            return localVarFp.orgsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {PatchOrgRequest} patchOrgRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsRename(orgId: string, patchOrgRequest: PatchOrgRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsRename(orgId, patchOrgRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subdomain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsResolveSubdomain(subdomain: string, options?: any): AxiosPromise<string> {
            return localVarFp.orgsResolveSubdomain(subdomain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganisationsApi - object-oriented interface
 * @export
 * @class OrganisationsApi
 * @extends {BaseAPI}
 */
export class OrganisationsApi extends BaseAPI {
    /**
     * 
     * @param {NewOrganisationRequest} newOrganisationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public orgsCreate(newOrganisationRequest: NewOrganisationRequest, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).orgsCreate(newOrganisationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {CreateSubdomainRequest} createSubdomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public orgsCreateSubdomain(orgId: string, createSubdomainRequest: CreateSubdomainRequest, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).orgsCreateSubdomain(orgId, createSubdomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public orgsDelete(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).orgsDelete(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public orgsGet(orgId: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).orgsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organisation  List all the organisations that the authenticated user is a member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public orgsList(options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).orgsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {PatchOrgRequest} patchOrgRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public orgsRename(orgId: string, patchOrgRequest: PatchOrgRequest, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).orgsRename(orgId, patchOrgRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subdomain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public orgsResolveSubdomain(subdomain: string, options?: RawAxiosRequestConfig) {
        return OrganisationsApiFp(this.configuration).orgsResolveSubdomain(subdomain, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordResetsApi - axios parameter creator
 * @export
 */
export const PasswordResetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPasswordResetReset: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('userPasswordResetReset', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/auth/reset/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendPasswordResetRequest} sendPasswordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPasswordResetSend: async (sendPasswordResetRequest: SendPasswordResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendPasswordResetRequest' is not null or undefined
            assertParamExists('userPasswordResetSend', 'sendPasswordResetRequest', sendPasswordResetRequest)
            const localVarPath = `/auth/reset/password/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendPasswordResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordResetsApi - functional programming interface
 * @export
 */
export const PasswordResetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordResetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPasswordResetReset(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPasswordResetReset(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordResetsApi.userPasswordResetReset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendPasswordResetRequest} sendPasswordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPasswordResetSend(sendPasswordResetRequest: SendPasswordResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPasswordResetSend(sendPasswordResetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordResetsApi.userPasswordResetSend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordResetsApi - factory interface
 * @export
 */
export const PasswordResetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordResetsApiFp(configuration)
    return {
        /**
         * 
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPasswordResetReset(resetPasswordRequest: ResetPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userPasswordResetReset(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendPasswordResetRequest} sendPasswordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPasswordResetSend(sendPasswordResetRequest: SendPasswordResetRequest, options?: any): AxiosPromise<void> {
            return localVarFp.userPasswordResetSend(sendPasswordResetRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasswordResetsApi - object-oriented interface
 * @export
 * @class PasswordResetsApi
 * @extends {BaseAPI}
 */
export class PasswordResetsApi extends BaseAPI {
    /**
     * 
     * @param {ResetPasswordRequest} resetPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordResetsApi
     */
    public userPasswordResetReset(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return PasswordResetsApiFp(this.configuration).userPasswordResetReset(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendPasswordResetRequest} sendPasswordResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordResetsApi
     */
    public userPasswordResetSend(sendPasswordResetRequest: SendPasswordResetRequest, options?: RawAxiosRequestConfig) {
        return PasswordResetsApiFp(this.configuration).userPasswordResetSend(sendPasswordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestionGroupsApi - axios parameter creator
 * @export
 */
export const QuestionGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {NewQuestionGroupRequest} newQuestionGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsCreate: async (orgId: string, formId: string, newQuestionGroupRequest: NewQuestionGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionGroupsCreate', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionGroupsCreate', 'formId', formId)
            // verify required parameter 'newQuestionGroupRequest' is not null or undefined
            assertParamExists('questionGroupsCreate', 'newQuestionGroupRequest', newQuestionGroupRequest)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/groups`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newQuestionGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsDelete: async (orgId: string, formId: string, questionGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionGroupsDelete', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionGroupsDelete', 'formId', formId)
            // verify required parameter 'questionGroupId' is not null or undefined
            assertParamExists('questionGroupsDelete', 'questionGroupId', questionGroupId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/groups/{question_group_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"question_group_id"}}`, encodeURIComponent(String(questionGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsList: async (orgId: string, formId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionGroupsList', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionGroupsList', 'formId', formId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/groups`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {APIQuestionGroup} aPIQuestionGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsSet: async (orgId: string, formId: string, questionGroupId: string, aPIQuestionGroup: APIQuestionGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionGroupsSet', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionGroupsSet', 'formId', formId)
            // verify required parameter 'questionGroupId' is not null or undefined
            assertParamExists('questionGroupsSet', 'questionGroupId', questionGroupId)
            // verify required parameter 'aPIQuestionGroup' is not null or undefined
            assertParamExists('questionGroupsSet', 'aPIQuestionGroup', aPIQuestionGroup)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/groups/{question_group_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"question_group_id"}}`, encodeURIComponent(String(questionGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIQuestionGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionGroupsApi - functional programming interface
 * @export
 */
export const QuestionGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {NewQuestionGroupRequest} newQuestionGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionGroupsCreate(orgId: string, formId: string, newQuestionGroupRequest: NewQuestionGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionGroupsCreate(orgId, formId, newQuestionGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionGroupsApi.questionGroupsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionGroupsDelete(orgId: string, formId: string, questionGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionGroupsDelete(orgId, formId, questionGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionGroupsApi.questionGroupsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionGroupsList(orgId: string, formId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIQuestionGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionGroupsList(orgId, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionGroupsApi.questionGroupsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {APIQuestionGroup} aPIQuestionGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionGroupsSet(orgId: string, formId: string, questionGroupId: string, aPIQuestionGroup: APIQuestionGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionGroupsSet(orgId, formId, questionGroupId, aPIQuestionGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionGroupsApi.questionGroupsSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestionGroupsApi - factory interface
 * @export
 */
export const QuestionGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionGroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {NewQuestionGroupRequest} newQuestionGroupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsCreate(orgId: string, formId: string, newQuestionGroupRequest: NewQuestionGroupRequest, options?: any): AxiosPromise<string> {
            return localVarFp.questionGroupsCreate(orgId, formId, newQuestionGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsDelete(orgId: string, formId: string, questionGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.questionGroupsDelete(orgId, formId, questionGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsList(orgId: string, formId: string, options?: any): AxiosPromise<Array<APIQuestionGroup>> {
            return localVarFp.questionGroupsList(orgId, formId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {APIQuestionGroup} aPIQuestionGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionGroupsSet(orgId: string, formId: string, questionGroupId: string, aPIQuestionGroup: APIQuestionGroup, options?: any): AxiosPromise<void> {
            return localVarFp.questionGroupsSet(orgId, formId, questionGroupId, aPIQuestionGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionGroupsApi - object-oriented interface
 * @export
 * @class QuestionGroupsApi
 * @extends {BaseAPI}
 */
export class QuestionGroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {NewQuestionGroupRequest} newQuestionGroupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionGroupsApi
     */
    public questionGroupsCreate(orgId: string, formId: string, newQuestionGroupRequest: NewQuestionGroupRequest, options?: RawAxiosRequestConfig) {
        return QuestionGroupsApiFp(this.configuration).questionGroupsCreate(orgId, formId, newQuestionGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} questionGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionGroupsApi
     */
    public questionGroupsDelete(orgId: string, formId: string, questionGroupId: string, options?: RawAxiosRequestConfig) {
        return QuestionGroupsApiFp(this.configuration).questionGroupsDelete(orgId, formId, questionGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionGroupsApi
     */
    public questionGroupsList(orgId: string, formId: string, options?: RawAxiosRequestConfig) {
        return QuestionGroupsApiFp(this.configuration).questionGroupsList(orgId, formId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} questionGroupId 
     * @param {APIQuestionGroup} aPIQuestionGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionGroupsApi
     */
    public questionGroupsSet(orgId: string, formId: string, questionGroupId: string, aPIQuestionGroup: APIQuestionGroup, options?: RawAxiosRequestConfig) {
        return QuestionGroupsApiFp(this.configuration).questionGroupsSet(orgId, formId, questionGroupId, aPIQuestionGroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestionsApi - axios parameter creator
 * @export
 */
export const QuestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {CreateQuestionRequest} createQuestionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsCreate: async (orgId: string, formId: string, questionGroupId: string, createQuestionRequest: CreateQuestionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionsCreate', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionsCreate', 'formId', formId)
            // verify required parameter 'questionGroupId' is not null or undefined
            assertParamExists('questionsCreate', 'questionGroupId', questionGroupId)
            // verify required parameter 'createQuestionRequest' is not null or undefined
            assertParamExists('questionsCreate', 'createQuestionRequest', createQuestionRequest)
            const localVarPath = `/users/me/orgs/{_org_id}/forms/{form_id}/groups/{question_group_id}/questions`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"question_group_id"}}`, encodeURIComponent(String(questionGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsDelete: async (orgId: string, formId: string, questionGroupId: string, questionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionsDelete', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionsDelete', 'formId', formId)
            // verify required parameter 'questionGroupId' is not null or undefined
            assertParamExists('questionsDelete', 'questionGroupId', questionGroupId)
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('questionsDelete', 'questionId', questionId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/groups/{question_group_id}/questions/{question_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"question_group_id"}}`, encodeURIComponent(String(questionGroupId)))
                .replace(`{${"question_id"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsGet: async (orgId: string, formId: string, questionGroupId: string, questionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionsGet', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionsGet', 'formId', formId)
            // verify required parameter 'questionGroupId' is not null or undefined
            assertParamExists('questionsGet', 'questionGroupId', questionGroupId)
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('questionsGet', 'questionId', questionId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/groups/{question_group_id}/questions/{question_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"question_group_id"}}`, encodeURIComponent(String(questionGroupId)))
                .replace(`{${"question_id"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsList: async (orgId: string, formId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionsList', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionsList', 'formId', formId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/groups/all/questions`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {APIQuestion} aPIQuestion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsSet: async (orgId: string, formId: string, questionGroupId: string, questionId: string, aPIQuestion: APIQuestion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('questionsSet', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('questionsSet', 'formId', formId)
            // verify required parameter 'questionGroupId' is not null or undefined
            assertParamExists('questionsSet', 'questionGroupId', questionGroupId)
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('questionsSet', 'questionId', questionId)
            // verify required parameter 'aPIQuestion' is not null or undefined
            assertParamExists('questionsSet', 'aPIQuestion', aPIQuestion)
            const localVarPath = `/users/me/orgs/{_org_id}/forms/{form_id}/groups/{question_group_id}/questions/{question_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"question_group_id"}}`, encodeURIComponent(String(questionGroupId)))
                .replace(`{${"question_id"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIQuestion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionsApi - functional programming interface
 * @export
 */
export const QuestionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {CreateQuestionRequest} createQuestionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsCreate(orgId: string, formId: string, questionGroupId: string, createQuestionRequest: CreateQuestionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIQuestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsCreate(orgId, formId, questionGroupId, createQuestionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsApi.questionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsDelete(orgId: string, formId: string, questionGroupId: string, questionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsDelete(orgId, formId, questionGroupId, questionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsApi.questionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsGet(orgId: string, formId: string, questionGroupId: string, questionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIQuestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsGet(orgId, formId, questionGroupId, questionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsApi.questionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsList(orgId: string, formId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIQuestion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsList(orgId, formId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsApi.questionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {APIQuestion} aPIQuestion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsSet(orgId: string, formId: string, questionGroupId: string, questionId: string, aPIQuestion: APIQuestion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIQuestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsSet(orgId, formId, questionGroupId, questionId, aPIQuestion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsApi.questionsSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestionsApi - factory interface
 * @export
 */
export const QuestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {CreateQuestionRequest} createQuestionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsCreate(orgId: string, formId: string, questionGroupId: string, createQuestionRequest: CreateQuestionRequest, options?: any): AxiosPromise<APIQuestion> {
            return localVarFp.questionsCreate(orgId, formId, questionGroupId, createQuestionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsDelete(orgId: string, formId: string, questionGroupId: string, questionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.questionsDelete(orgId, formId, questionGroupId, questionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsGet(orgId: string, formId: string, questionGroupId: string, questionId: string, options?: any): AxiosPromise<APIQuestion> {
            return localVarFp.questionsGet(orgId, formId, questionGroupId, questionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsList(orgId: string, formId: string, options?: any): AxiosPromise<Array<APIQuestion>> {
            return localVarFp.questionsList(orgId, formId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} questionGroupId 
         * @param {string} questionId 
         * @param {APIQuestion} aPIQuestion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsSet(orgId: string, formId: string, questionGroupId: string, questionId: string, aPIQuestion: APIQuestion, options?: any): AxiosPromise<APIQuestion> {
            return localVarFp.questionsSet(orgId, formId, questionGroupId, questionId, aPIQuestion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionsApi - object-oriented interface
 * @export
 * @class QuestionsApi
 * @extends {BaseAPI}
 */
export class QuestionsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} questionGroupId 
     * @param {CreateQuestionRequest} createQuestionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionsCreate(orgId: string, formId: string, questionGroupId: string, createQuestionRequest: CreateQuestionRequest, options?: RawAxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionsCreate(orgId, formId, questionGroupId, createQuestionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} questionGroupId 
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionsDelete(orgId: string, formId: string, questionGroupId: string, questionId: string, options?: RawAxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionsDelete(orgId, formId, questionGroupId, questionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} questionGroupId 
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionsGet(orgId: string, formId: string, questionGroupId: string, questionId: string, options?: RawAxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionsGet(orgId, formId, questionGroupId, questionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionsList(orgId: string, formId: string, options?: RawAxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionsList(orgId, formId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} questionGroupId 
     * @param {string} questionId 
     * @param {APIQuestion} aPIQuestion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsApi
     */
    public questionsSet(orgId: string, formId: string, questionGroupId: string, questionId: string, aPIQuestion: APIQuestion, options?: RawAxiosRequestConfig) {
        return QuestionsApiFp(this.configuration).questionsSet(orgId, formId, questionGroupId, questionId, aPIQuestion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubmissionAssetApi - axios parameter creator
 * @export
 */
export const SubmissionAssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionAssetsGetLink: async (orgId: string, formId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('submissionAssetsGetLink', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('submissionAssetsGetLink', 'formId', formId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('submissionAssetsGetLink', 'fileId', fileId)
            const localVarPath = `/user/me/orgs/{_org_id}/forms/{form_id}/submission-assets/{file_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionAssetApi - functional programming interface
 * @export
 */
export const SubmissionAssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmissionAssetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionAssetsGetLink(orgId: string, formId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionAssetsGetLink(orgId, formId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmissionAssetApi.submissionAssetsGetLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubmissionAssetApi - factory interface
 * @export
 */
export const SubmissionAssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmissionAssetApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionAssetsGetLink(orgId: string, formId: string, fileId: string, options?: any): AxiosPromise<Array<number>> {
            return localVarFp.submissionAssetsGetLink(orgId, formId, fileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmissionAssetApi - object-oriented interface
 * @export
 * @class SubmissionAssetApi
 * @extends {BaseAPI}
 */
export class SubmissionAssetApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionAssetApi
     */
    public submissionAssetsGetLink(orgId: string, formId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return SubmissionAssetApiFp(this.configuration).submissionAssetsGetLink(orgId, formId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubmissionsApi - axios parameter creator
 * @export
 */
export const SubmissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsCrypto: async (orgId: string, formId: string, submissionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('submissionsCrypto', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('submissionsCrypto', 'formId', formId)
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsCrypto', 'submissionId', submissionId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/submissions/{submission_id}/crypto`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsDelete: async (orgId: string, formId: string, submissionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('submissionsDelete', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('submissionsDelete', 'formId', formId)
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionsDelete', 'submissionId', submissionId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/submissions/{submission_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Editor_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsList: async (orgId: string, formId: string, since?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('submissionsList', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('submissionsList', 'formId', formId)
            const localVarPath = `/users/me/orgs/{org_id}/forms/{form_id}/submissions`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromForm_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {SubmissionCountSinceRequest} submissionCountSinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsNumSince: async (orgId: string, submissionCountSinceRequest: SubmissionCountSinceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('submissionsNumSince', 'orgId', orgId)
            // verify required parameter 'submissionCountSinceRequest' is not null or undefined
            assertParamExists('submissionsNumSince', 'submissionCountSinceRequest', submissionCountSinceRequest)
            const localVarPath = `/users/me/orgs/{org_id}/submissions`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submissionCountSinceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionsApi - functional programming interface
 * @export
 */
export const SubmissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsCrypto(orgId: string, formId: string, submissionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionCryptoDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsCrypto(orgId, formId, submissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmissionsApi.submissionsCrypto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsDelete(orgId: string, formId: string, submissionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsDelete(orgId, formId, submissionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmissionsApi.submissionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsList(orgId: string, formId: string, since?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APISubmissionStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsList(orgId, formId, since, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmissionsApi.submissionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {SubmissionCountSinceRequest} submissionCountSinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionsNumSince(orgId: string, submissionCountSinceRequest: SubmissionCountSinceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APISubmissionCountPerForm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionsNumSince(orgId, submissionCountSinceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmissionsApi.submissionsNumSince']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubmissionsApi - factory interface
 * @export
 */
export const SubmissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmissionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsCrypto(orgId: string, formId: string, submissionId: string, options?: any): AxiosPromise<SubmissionCryptoDetailsResponse> {
            return localVarFp.submissionsCrypto(orgId, formId, submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsDelete(orgId: string, formId: string, submissionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.submissionsDelete(orgId, formId, submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} [since] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsList(orgId: string, formId: string, since?: string, options?: any): AxiosPromise<APISubmissionStream> {
            return localVarFp.submissionsList(orgId, formId, since, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {SubmissionCountSinceRequest} submissionCountSinceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionsNumSince(orgId: string, submissionCountSinceRequest: SubmissionCountSinceRequest, options?: any): AxiosPromise<Array<APISubmissionCountPerForm>> {
            return localVarFp.submissionsNumSince(orgId, submissionCountSinceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmissionsApi - object-oriented interface
 * @export
 * @class SubmissionsApi
 * @extends {BaseAPI}
 */
export class SubmissionsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsCrypto(orgId: string, formId: string, submissionId: string, options?: RawAxiosRequestConfig) {
        return SubmissionsApiFp(this.configuration).submissionsCrypto(orgId, formId, submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsDelete(orgId: string, formId: string, submissionId: string, options?: RawAxiosRequestConfig) {
        return SubmissionsApiFp(this.configuration).submissionsDelete(orgId, formId, submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} [since] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsList(orgId: string, formId: string, since?: string, options?: RawAxiosRequestConfig) {
        return SubmissionsApiFp(this.configuration).submissionsList(orgId, formId, since, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {SubmissionCountSinceRequest} submissionCountSinceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public submissionsNumSince(orgId: string, submissionCountSinceRequest: SubmissionCountSinceRequest, options?: RawAxiosRequestConfig) {
        return SubmissionsApiFp(this.configuration).submissionsNumSince(orgId, submissionCountSinceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamAssetsApi - axios parameter creator
 * @export
 */
export const TeamAssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamAssetGet: async (orgId: string, teamId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamAssetGet', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamAssetGet', 'teamId', teamId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('organisationTeamAssetGet', 'assetId', assetId)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}/assets/{asset_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamAssetGetForFormFill: async (orgId: string, formId: string, assetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamAssetGetForFormFill', 'orgId', orgId)
            // verify required parameter 'formId' is not null or undefined
            assertParamExists('organisationTeamAssetGetForFormFill', 'formId', formId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('organisationTeamAssetGetForFormFill', 'assetId', assetId)
            const localVarPath = `/fill/orgs/{_org_id}/forms/{form_id}/assets/{asset_id}`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"form_id"}}`, encodeURIComponent(String(formId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIFillAccessToken required
            await setApiKeyToObject(localVarQueryParameter, "f", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamAssetList: async (orgId: string, teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('organisationTeamAssetList', 'orgId', orgId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('organisationTeamAssetList', 'teamId', teamId)
            const localVarPath = `/users/me/orgs/{_org_id}/teams/{team_id}/assets`
                .replace(`{${"_org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_Viewer_OrgViewAndTeamRoleFromTeam_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamAssetsApi - functional programming interface
 * @export
 */
export const TeamAssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamAssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamAssetGet(orgId: string, teamId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamAssetGet(orgId, teamId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamAssetsApi.organisationTeamAssetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamAssetGetForFormFill(orgId: string, formId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamAssetGetForFormFill(orgId, formId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamAssetsApi.organisationTeamAssetGetForFormFill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organisationTeamAssetList(orgId: string, teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APITeamAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organisationTeamAssetList(orgId, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamAssetsApi.organisationTeamAssetList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamAssetsApi - factory interface
 * @export
 */
export const TeamAssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamAssetsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamAssetGet(orgId: string, teamId: string, assetId: string, options?: any): AxiosPromise<string> {
            return localVarFp.organisationTeamAssetGet(orgId, teamId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} formId 
         * @param {string} assetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamAssetGetForFormFill(orgId: string, formId: string, assetId: string, options?: any): AxiosPromise<APIError> {
            return localVarFp.organisationTeamAssetGetForFormFill(orgId, formId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organisationTeamAssetList(orgId: string, teamId: string, options?: any): AxiosPromise<Array<APITeamAsset>> {
            return localVarFp.organisationTeamAssetList(orgId, teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamAssetsApi - object-oriented interface
 * @export
 * @class TeamAssetsApi
 * @extends {BaseAPI}
 */
export class TeamAssetsApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAssetsApi
     */
    public organisationTeamAssetGet(orgId: string, teamId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return TeamAssetsApiFp(this.configuration).organisationTeamAssetGet(orgId, teamId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} formId 
     * @param {string} assetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAssetsApi
     */
    public organisationTeamAssetGetForFormFill(orgId: string, formId: string, assetId: string, options?: RawAxiosRequestConfig) {
        return TeamAssetsApiFp(this.configuration).organisationTeamAssetGetForFormFill(orgId, formId, assetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAssetsApi
     */
    public organisationTeamAssetList(orgId: string, teamId: string, options?: RawAxiosRequestConfig) {
        return TeamAssetsApiFp(this.configuration).organisationTeamAssetList(orgId, teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserKeysApi - axios parameter creator
 * @export
 */
export const UserKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysDelete: async (orgId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('keysDelete', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('keysDelete', 'keyId', keyId)
            const localVarPath = `/users/me/orgs/{org_id}/keys/{key_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication APIAuthTokenWithRole_None_OrgAdmin_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysGet: async (orgId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('keysGet', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('keysGet', 'keyId', keyId)
            const localVarPath = `/users/me/orgs/{org_id}/keys/{key_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysGetBackup: async (orgId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('keysGetBackup', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('keysGetBackup', 'keyId', keyId)
            const localVarPath = `/users/me/orgs/{org_id}/keys/{key_id}/backup`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user keys  Lists the public keys associated with the currently authenticated user\'s account in PEM-encoded format.
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysList: async (org: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('keysList', 'org', org)
            const localVarPath = `/users/me/orgs/{org}/keys`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register new public key  Registers a new public to the authenticated user\'s account. The key is stored in DER-encoded binary in the database and can be retrieved using the GET /users/me/key endpoint.
         * @param {string} org 
         * @param {RegisterKeyRequest} registerKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysRegister: async (org: string, registerKeyRequest: RegisterKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('keysRegister', 'org', org)
            // verify required parameter 'registerKeyRequest' is not null or undefined
            assertParamExists('keysRegister', 'registerKeyRequest', registerKeyRequest)
            const localVarPath = `/users/me/orgs/{org}/keys`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {RegisterBackupKeyRequest} registerBackupKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysRegisterBackup: async (orgId: string, keyId: string, registerBackupKeyRequest: RegisterBackupKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('keysRegisterBackup', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('keysRegisterBackup', 'keyId', keyId)
            // verify required parameter 'registerBackupKeyRequest' is not null or undefined
            assertParamExists('keysRegisterBackup', 'registerBackupKeyRequest', registerBackupKeyRequest)
            const localVarPath = `/users/me/orgs/{org_id}/keys/{key_id}/backup`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIAuthTokenWithRole_None_OrgView_Any required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerBackupKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserKeysApi - functional programming interface
 * @export
 */
export const UserKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysDelete(orgId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysDelete(orgId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserKeysApi.keysDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysGet(orgId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIUserKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysGet(orgId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserKeysApi.keysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysGetBackup(orgId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysGetBackup(orgId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserKeysApi.keysGetBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List user keys  Lists the public keys associated with the currently authenticated user\'s account in PEM-encoded format.
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysList(org: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIUserKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysList(org, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserKeysApi.keysList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register new public key  Registers a new public to the authenticated user\'s account. The key is stored in DER-encoded binary in the database and can be retrieved using the GET /users/me/key endpoint.
         * @param {string} org 
         * @param {RegisterKeyRequest} registerKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysRegister(org: string, registerKeyRequest: RegisterKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysRegister(org, registerKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserKeysApi.keysRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {RegisterBackupKeyRequest} registerBackupKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysRegisterBackup(orgId: string, keyId: string, registerBackupKeyRequest: RegisterBackupKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysRegisterBackup(orgId, keyId, registerBackupKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserKeysApi.keysRegisterBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserKeysApi - factory interface
 * @export
 */
export const UserKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserKeysApiFp(configuration)
    return {
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysDelete(orgId: string, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.keysDelete(orgId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysGet(orgId: string, keyId: string, options?: any): AxiosPromise<APIUserKey> {
            return localVarFp.keysGet(orgId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysGetBackup(orgId: string, keyId: string, options?: any): AxiosPromise<string> {
            return localVarFp.keysGetBackup(orgId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List user keys  Lists the public keys associated with the currently authenticated user\'s account in PEM-encoded format.
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysList(org: string, options?: any): AxiosPromise<Array<APIUserKey>> {
            return localVarFp.keysList(org, options).then((request) => request(axios, basePath));
        },
        /**
         * Register new public key  Registers a new public to the authenticated user\'s account. The key is stored in DER-encoded binary in the database and can be retrieved using the GET /users/me/key endpoint.
         * @param {string} org 
         * @param {RegisterKeyRequest} registerKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysRegister(org: string, registerKeyRequest: RegisterKeyRequest, options?: any): AxiosPromise<string> {
            return localVarFp.keysRegister(org, registerKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} keyId 
         * @param {RegisterBackupKeyRequest} registerBackupKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysRegisterBackup(orgId: string, keyId: string, registerBackupKeyRequest: RegisterBackupKeyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.keysRegisterBackup(orgId, keyId, registerBackupKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserKeysApi - object-oriented interface
 * @export
 * @class UserKeysApi
 * @extends {BaseAPI}
 */
export class UserKeysApi extends BaseAPI {
    /**
     * 
     * @param {string} orgId 
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserKeysApi
     */
    public keysDelete(orgId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return UserKeysApiFp(this.configuration).keysDelete(orgId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserKeysApi
     */
    public keysGet(orgId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return UserKeysApiFp(this.configuration).keysGet(orgId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserKeysApi
     */
    public keysGetBackup(orgId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return UserKeysApiFp(this.configuration).keysGetBackup(orgId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user keys  Lists the public keys associated with the currently authenticated user\'s account in PEM-encoded format.
     * @param {string} org 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserKeysApi
     */
    public keysList(org: string, options?: RawAxiosRequestConfig) {
        return UserKeysApiFp(this.configuration).keysList(org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register new public key  Registers a new public to the authenticated user\'s account. The key is stored in DER-encoded binary in the database and can be retrieved using the GET /users/me/key endpoint.
     * @param {string} org 
     * @param {RegisterKeyRequest} registerKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserKeysApi
     */
    public keysRegister(org: string, registerKeyRequest: RegisterKeyRequest, options?: RawAxiosRequestConfig) {
        return UserKeysApiFp(this.configuration).keysRegister(org, registerKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {string} keyId 
     * @param {RegisterBackupKeyRequest} registerBackupKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserKeysApi
     */
    public keysRegisterBackup(orgId: string, keyId: string, registerBackupKeyRequest: RegisterBackupKeyRequest, options?: RawAxiosRequestConfig) {
        return UserKeysApiFp(this.configuration).keysRegisterBackup(orgId, keyId, registerBackupKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



